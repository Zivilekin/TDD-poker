"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = require("lodash");
const write_json_1 = __importDefault(require("yoshi-common/build/write-json"));
async function verifyTypeScriptReferences({ graph, }) {
    await Promise.all(Array.from(graph).map(async ([, pkg]) => {
        const tsconfigPath = path_1.default.join(pkg.location, 'tsconfig.json');
        const tsconfig = await fs_extra_1.default.readJSON(tsconfigPath);
        const references = Array.from(pkg.localDependencies)
            .map(([depName]) => {
            return path_1.default.relative(pkg.location, graph.get(depName).location);
        })
            .map(relativePath => ({ path: relativePath }));
        const clonedTsconfig = Object.assign(Object.assign({}, tsconfig), { references });
        // Don't write empty references
        if (clonedTsconfig.references.length === 0) {
            delete clonedTsconfig.references;
        }
        // Only update `tsconfig` and show a message if an update is needed
        if (!lodash_1.isEqual(clonedTsconfig, tsconfig)) {
            console.log(chalk_1.default.bold(`Changes have been made to the references of ${chalk_1.default.cyan(path_1.default.relative(process.cwd(), tsconfigPath))}.`));
            write_json_1.default(tsconfigPath, clonedTsconfig);
        }
    }));
    console.log();
}
exports.default = verifyTypeScriptReferences;
//# sourceMappingURL=verify-typescript-references.js.map