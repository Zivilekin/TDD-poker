"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const execa_1 = __importDefault(require("execa"));
const chalk_1 = __importDefault(require("chalk"));
const globby_1 = __importDefault(require("globby"));
const paths_1 = require("yoshi-config/build/paths");
async function build(pkgs) {
    const pkgsLocations = pkgs.map(pkg => pkg.location);
    try {
        await execa_1.default(`npx tsc -b ${pkgsLocations.join(' ')}`, {
            stdio: 'inherit',
            shell: true,
        });
    }
    catch (error) {
        console.log(chalk_1.default.red('Failed to compile.\n'));
        console.error(error.stack);
        process.exit(1);
    }
    pkgs.forEach(pkg => {
        const assets = globby_1.default.sync('src/**/*', {
            cwd: pkg.location,
            ignore: ['**/*.js', '**/*.ts', '**/*.tsx', '**/*.json', '**/*.snap'],
        });
        assets.forEach(assetPath => {
            const dirname = path_1.default.join(pkg.location, paths_1.BUILD_DIR, assetPath);
            fs_extra_1.default.ensureDirSync(path_1.default.dirname(dirname));
            fs_extra_1.default.copyFileSync(path_1.default.join(pkg.location, assetPath), dirname);
        });
    });
}
exports.default = build;
//# sourceMappingURL=build.js.map