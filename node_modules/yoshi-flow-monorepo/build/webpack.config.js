"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSiteAssetsWebpackConfig = exports.createWebWorkerServerWebpackConfig = exports.createWebWorkerWebpackConfig = exports.createServerWebpackConfig = exports.createClientWebpackConfig = void 0;
const path_1 = __importDefault(require("path"));
// eslint-disable-next-line import/no-extraneous-dependencies
const webpack_1 = __importDefault(require("webpack"));
const webpack_utils_1 = require("yoshi-common/build/webpack-utils");
// @ts-ignore
const webpack_stats_plugin_1 = require("webpack-stats-plugin");
const webpack_config_1 = require("yoshi-common/build/webpack.config");
const constants_1 = require("yoshi-helpers/build/constants");
const queries_1 = require("yoshi-helpers/build/queries");
const paths_1 = require("yoshi-config/build/paths");
const manifest_webpack_plugin_1 = __importDefault(require("yoshi-common/build/manifest-webpack-plugin"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const useTypeScript = queries_1.isTypescriptProject();
const isProduction = queries_1.isProduction();
const defaultSplitChunksConfig = {
    chunks: 'all',
    name: 'commons',
    minChunks: 2,
};
const createDefaultOptions = (pkg, libs, apps, rootConfig) => {
    const separateCss = pkg.config.separateCss === 'prod'
        ? queries_1.inTeamCity() || isProduction
        : pkg.config.separateCss;
    return {
        name: pkg.config.name,
        useTypeScript,
        typeCheckTypeScript: false,
        useAngular: pkg.config.isAngularProject,
        devServerUrl: pkg.config.servers.cdn.url,
        cssModules: pkg.config.cssModules,
        separateCss,
        includeInTranspilation: [
            ...[...apps, ...libs].map(({ location }) => path_1.default.join(location, paths_1.SRC_DIR)),
            ...rootConfig.externalUnprocessedModules.map(m => new RegExp(`node_modules/${m}`)),
        ],
        umdNamedDefine: pkg.config.umdNamedDefine,
    };
};
function createClientWebpackConfig(rootConfig, pkg, libs, apps, { isDev, isHot, suricate, isAnalyze, forceEmitSourceMaps, forceEmitStats, } = {}) {
    const entry = pkg.config.entry || constants_1.defaultEntry;
    const defaultOptions = createDefaultOptions(pkg, libs, apps, rootConfig);
    const clientConfig = webpack_config_1.createBaseWebpackConfig(Object.assign({ cwd: pkg.location, configName: 'client', target: 'web', isDev,
        isHot,
        suricate, isMonorepo: true, isAnalyze,
        forceEmitSourceMaps,
        forceEmitStats, exportAsLibraryName: pkg.config.exports, enhancedTpaStyle: pkg.config.enhancedTpaStyle, tpaStyle: pkg.config.tpaStyle, separateStylableCss: pkg.config.separateStylableCss, createEjsTemplates: pkg.config.experimentalBuildHtml, useCustomSourceMapPlugin: utils_1.isThunderboltElementModule(pkg) || utils_1.isThunderboltAppModule(pkg), 
        // Because CSS assets are inlined in the initial HTML response, images
        // and other assets they reference has to have absolute URLs
        useAbsoluteUrlsForCssAssets: utils_1.isThunderboltElementModule(pkg) || utils_1.isThunderboltAppModule(pkg) }, defaultOptions));
    if (utils_1.isThunderboltElementModule(pkg)) {
        clientConfig.optimization.runtimeChunk = false;
    }
    clientConfig.entry = queries_1.isSingleEntry(entry) ? { app: entry } : entry;
    clientConfig.resolve.alias = pkg.config.resolveAlias;
    clientConfig.externals = pkg.config.externals;
    const useSplitChunks = pkg.config.splitChunks;
    // Thunderbolt and editor elements need a smaller version
    // of the stats to be uploaded to the cdn
    // This is being analyzed later on during render time
    if (utils_1.isThunderboltElementModule(pkg) || utils_1.isThunderboltAppModule(pkg)) {
        let statsFileName = null;
        // build command, production bundle
        if (isProduction && !isDev) {
            statsFileName = 'stats.min.json';
        }
        // start command, development bundle
        if (!isProduction && isDev) {
            statsFileName = 'stats.json';
        }
        // We want to emit the production stats only when running yoshi build
        // We want to emit the development stats only when running yoshi start
        if (statsFileName) {
            clientConfig.plugins.push(new webpack_stats_plugin_1.StatsWriterPlugin({
                filename: statsFileName,
                // https://webpack.js.org/configuration/stats/#stats
                stats: {
                    all: false,
                    chunkGroups: true,
                    publicPath: true,
                },
                transform(data) {
                    // By default, the stats file contain spaces an indentation
                    // This verifies it's minified
                    return JSON.stringify(data);
                },
            }));
        }
    }
    if (useSplitChunks) {
        const splitChunksConfig = lodash_1.isObject(useSplitChunks)
            ? useSplitChunks
            : defaultSplitChunksConfig;
        clientConfig.optimization.splitChunks = splitChunksConfig;
    }
    return clientConfig;
}
exports.createClientWebpackConfig = createClientWebpackConfig;
function createServerWebpackConfig(rootConfig, pkg, libs, apps, { isDev, isHot } = {}) {
    const defaultOptions = createDefaultOptions(pkg, libs, apps, rootConfig);
    const serverConfig = webpack_config_1.createBaseWebpackConfig(Object.assign({ cwd: pkg.location, configName: 'server', target: 'node', isDev,
        isHot, isMonorepo: true, nodeExternalsWhitelist: libs.map(pkg => new RegExp(pkg.name)), useAssetRelocator: pkg.config.experimentalUseAssetRelocator, forceMinimizeServer: utils_1.isThunderboltElementModule(pkg), serverExternals: pkg.config.serverExternals }, defaultOptions));
    if (utils_1.isThunderboltElementModule(pkg)) {
        // output to /dist/statics so it's available for thunderbolt to download
        serverConfig.output.path = path_1.default.join(pkg.location, paths_1.STATICS_DIR);
        // create only 1 file regardless of dynamic imports so it's easier to download
        serverConfig.plugins.push(new webpack_1.default.optimize.LimitChunkCountPlugin({
            maxChunks: 1,
        }));
        // use cheap source maps to make download faster
        serverConfig.devtool = 'inline-cheap-source-map';
    }
    serverConfig.entry = async () => {
        const serverEntry = webpack_utils_1.validateServerEntry({
            cwd: pkg.location,
            extensions: serverConfig.resolve.extensions,
            yoshiServer: pkg.config.yoshiServer,
        });
        let entryConfig = pkg.config.yoshiServer
            ? webpack_utils_1.createServerEntries(serverConfig.context, pkg.location)
            : {};
        if (serverEntry) {
            entryConfig = Object.assign(Object.assign({}, entryConfig), { [paths_1.SERVER_ENTRY]: serverEntry });
        }
        return entryConfig;
    };
    return serverConfig;
}
exports.createServerWebpackConfig = createServerWebpackConfig;
function createWebWorkerWebpackConfig(rootConfig, pkg, libs, apps, { isDev, isHot, isAnalyze, forceEmitStats, } = {}) {
    const defaultOptions = createDefaultOptions(pkg, libs, apps, rootConfig);
    const workerConfig = webpack_config_1.createBaseWebpackConfig(Object.assign({ cwd: pkg.location, configName: 'web-worker', target: utils_1.isThunderboltElementModule(pkg) ? 'async-webworker' : 'webworker', isDev,
        isHot, isMonorepo: true, createEjsTemplates: pkg.config.experimentalBuildHtml, isAnalyze,
        forceEmitStats }, defaultOptions));
    // Use inline source maps since Thunderbolt loads worker as a blob locally
    if (!isProduction) {
        workerConfig.devtool = 'inline-source-map';
    }
    workerConfig.output.library = '[name]';
    workerConfig.output.libraryTarget = 'umd';
    workerConfig.output.globalObject = 'self';
    workerConfig.entry = pkg.config.webWorkerEntry;
    workerConfig.resolve.alias = pkg.config.webWorkerResolveAlias;
    workerConfig.externals = pkg.config.webWorkerExternals;
    return workerConfig;
}
exports.createWebWorkerWebpackConfig = createWebWorkerWebpackConfig;
function createWebWorkerServerWebpackConfig(rootConfig, pkg, libs, apps, { isDev, isHot } = {}) {
    const defaultOptions = createDefaultOptions(pkg, libs, apps, rootConfig);
    const workerConfig = webpack_config_1.createBaseWebpackConfig(Object.assign({ cwd: pkg.location, configName: 'web-worker-server', target: utils_1.isThunderboltElementModule(pkg) ? 'async-webworker' : 'webworker', isDev,
        isHot, isMonorepo: true, createWorkerManifest: false }, defaultOptions));
    workerConfig.output.library = '[name]';
    workerConfig.output.libraryTarget = 'umd';
    workerConfig.output.globalObject = 'self';
    workerConfig.entry = pkg.config.webWorkerServerEntry;
    workerConfig.plugins.push(new webpack_1.default.optimize.LimitChunkCountPlugin({
        maxChunks: 1,
    }));
    return workerConfig;
}
exports.createWebWorkerServerWebpackConfig = createWebWorkerServerWebpackConfig;
function createSiteAssetsWebpackConfig(rootConfig, pkg, libs, apps, { isDev, forceEmitSourceMaps, forceEmitStats, isAnalyze, target, transpileCarmiOutput, }) {
    const entry = pkg.config.entry || constants_1.defaultEntry;
    const defaultOptions = createDefaultOptions(pkg, libs, apps, rootConfig);
    const config = webpack_config_1.createBaseWebpackConfig(Object.assign({ cwd: pkg.location, configName: 'site-assets', target,
        isDev, isMonorepo: true, isAnalyze,
        forceEmitSourceMaps,
        forceEmitStats, 
        // We don't have any server externals for `site assets` bundle
        // So with empty object, we'll be sure that no default externals value will be applied
        serverExternals: target === 'node' ? {} : undefined, exportAsLibraryName: pkg.config.exports, enhancedTpaStyle: pkg.config.enhancedTpaStyle, tpaStyle: pkg.config.tpaStyle, separateStylableCss: pkg.config.separateStylableCss, createEjsTemplates: pkg.config.experimentalBuildHtml, transpileCarmiOutput }, defaultOptions));
    config.entry = queries_1.isSingleEntry(entry) ? { app: entry } : entry;
    const manifestName = target === 'node' ? 'manifest' : 'manifest-web';
    // for site-assets we have two minified compilations
    // for them to not override each other we'll rename the web one
    config.plugins.push(new manifest_webpack_plugin_1.default({ fileName: manifestName, isDev: isDev }));
    if (target === 'web') {
        // use a umd bundle for the web bundles
        config.output.libraryTarget = 'umd';
    }
    config.output.path = path_1.default.join(pkg.location, paths_1.STATICS_DIR);
    config.output.filename = isDev
        ? '[name].bundle.js'
        : '[name].[contenthash:8].bundle.min.js';
    config.output.chunkFilename = isDev
        ? '[name].chunk.js'
        : '[name].[contenthash:8].chunk.min.js';
    return config;
}
exports.createSiteAssetsWebpackConfig = createSiteAssetsWebpackConfig;
//# sourceMappingURL=webpack.config.js.map