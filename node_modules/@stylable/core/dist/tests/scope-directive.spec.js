"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var src_1 = require("../src");
var stylable_transformer_1 = require("../src/stylable-transformer");
var flat_match_1 = require("./matchers/flat-match");
var diagnostics_1 = require("./utils/diagnostics");
var generate_test_util_1 = require("./utils/generate-test-util");
chai_1.use(flat_match_1.flatMatch);
describe('@st-scope', function () {
    describe('processing scopes', function () {
        it('should parse "@st-scope" directives', function () {
            var meta = generate_test_util_1.processSource("\n                @st-scope .root{\n                    .part {}\n                }\n            ", { from: 'path/to/style.css' });
            diagnostics_1.shouldReportNoDiagnostics(meta);
            chai_1.expect(meta.scopes).to.flatMatch([{
                    type: 'atrule',
                    name: 'st-scope',
                    params: '.root'
                }]);
        });
        it('should parse "@st-scope" directives with a new class', function () {
            var meta = generate_test_util_1.processSource("\n                @st-scope .newClass {\n                    .part {}\n                }\n            ", { from: 'path/to/style.css' });
            diagnostics_1.shouldReportNoDiagnostics(meta);
            chai_1.expect(meta.scopes).to.flatMatch([{
                    type: 'atrule',
                    name: 'st-scope',
                    params: '.newClass'
                }]);
        });
        it('should mark scope ref name on impacted rules', function () {
            var meta = generate_test_util_1.processSource("\n                @st-scope .root {\n                    .part {}\n                    .otherPart {}\n                }\n            ", { from: 'path/to/style.css' });
            var rules = meta.ast.nodes;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            chai_1.expect(rules[0].selector).to.equal('.root .part');
            chai_1.expect(rules[1].selector).to.equal('.root .otherPart');
            chai_1.expect(rules[2]).to.eql(undefined);
        });
    });
    describe('transforming scoped selectors', function () {
        it('should scope "part" class to root', function () {
            var meta = generate_test_util_1.generateStylableResult({
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        @st-scope .root {\n                            .part {}\n                        }\n                        "
                    }
                }
            }).meta;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            chai_1.expect(meta.outputAst.nodes).to.flatMatch([{
                    selector: '.entry--root .entry--part'
                }
            ]);
        });
        it('should scope "part" class using a default import', function () {
            var meta = generate_test_util_1.generateStylableResult({
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        :import {\n                            -st-from: './imported.st.css';\n                            -st-default: Comp;\n                        }\n                        @st-scope Comp {\n                            .part {}\n                        }\n                        "
                    },
                    '/imported.st.css': {
                        namespace: 'imported',
                        content: ".root {}"
                    }
                }
            }).meta;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            chai_1.expect(meta.outputAst.first).to.flatMatch({
                selector: '.imported--root .entry--part'
            });
        });
        it('should scope "Comp" class using a default import', function () {
            var meta = generate_test_util_1.generateStylableResult({
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        :import {\n                            -st-from: './imported.st.css';\n                            -st-default: Comp;\n                        }\n                        @st-scope .root {\n                            Comp {}\n                        }\n                        "
                    },
                    '/imported.st.css': {
                        namespace: 'imported',
                        content: ".root {}"
                    }
                }
            }).meta;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            chai_1.expect(meta.outputAst.first).to.flatMatch({
                selector: '.entry--root .imported--root'
            });
        });
        it('scoped classes should not be mixable (into another class or element)', function () {
            var meta = generate_test_util_1.generateStylableResult({
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        :import {\n                            -st-from: './imported.st.css';\n                            -st-named: mymix;\n                        }\n                        .root {\n                            -st-mixin: mymix;\n                        }\n                        "
                    },
                    '/imported.st.css': {
                        namespace: 'imported',
                        content: "\n                        @st-scope .root {\n                            .mymix {\n                                color: red;\n                            }\n                        }"
                    }
                }
            }).meta;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            var rule = meta.outputAst.first;
            var decl = rule.first;
            chai_1.expect(decl).to.equal(undefined);
        });
        it('scoped classes should be agnostic about -st-extend', function () {
            var meta = generate_test_util_1.generateStylableResult({
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        :import {\n                            -st-from: './imported.st.css';\n                            -st-named: mymix;\n                        }\n                        .root {\n                            -st-extends: mymix;\n                        }\n                        .root:myState {\n                            color: red;\n                        }\n                        "
                    },
                    '/imported.st.css': {
                        namespace: 'imported',
                        content: "\n                        @st-scope .root {\n                            .mymix {\n                                -st-states: myState;\n                            }\n                        }"
                    }
                }
            }).meta;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            var rule = meta.outputAst.nodes[1];
            chai_1.expect(rule.selector).to.equal('.entry--root[data-imported-mystate]');
        });
        it('scope with media queries', function () {
            var meta = generate_test_util_1.generateStylableResult({
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        @st-scope .root {\n                            @media screen (max-width: 100px) {\n                                .part {}\n                            }\n                        }\n                        "
                    }
                }
            }).meta;
            diagnostics_1.shouldReportNoDiagnostics(meta);
            var atRule = meta.outputAst.nodes[0];
            var rule = atRule.nodes[0];
            chai_1.expect(rule.selector).to.equal('.entry--root .entry--part');
        });
    });
    describe('diagnostics', function () {
        it('should warn about multiple params in scope', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        .root {}\n                        .part {}\n                        |@st-scope $.root .part$ {\n                            .scopedPart {}\n                        }|\n                    "
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                { message: src_1.processorWarnings.SCOPE_PARAM_NOT_SIMPLE_SELECTOR('.root .part'),
                    file: '/entry.st.css', severity: 'warning' },
                { message: stylable_transformer_1.transformerWarnings.UNKNOWN_SCOPING_PARAM('.root .part'),
                    file: '/entry.st.css', severity: 'error' }
            ]).meta;
            // tslint:disable-next-line:max-line-length
            chai_1.expect(meta.outputAst.nodes[2].selector).to.equal('.entry--root .entry--part .entry--scopedPart');
            chai_1.expect(meta.scopes).to.flatMatch([{
                    type: 'atrule',
                    name: 'st-scope',
                    params: '.root .part'
                }]);
        });
        it('should warn about disallowed syntax as a scoping parameter', function () {
            diagnostics_1.expectWarnings("\n                |@st-scope $.root::before$ {\n                    .part {}\n                }|\n            ", [
                // tslint:disable-next-line:max-line-length
                { message: src_1.processorWarnings.SCOPE_PARAM_NOT_SIMPLE_SELECTOR('.root::before'), file: 'entry.st.css', severity: 'warning' }
            ]);
        });
        it('should warn about scoping with a symbol that does not resolve to a stylesheet root', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        :import {\n                            -st-from: './imported.st.css';\n                            -st-named: importedPart;\n                        }\n                        |@st-scope $importedPart$ {\n                            .part {}\n                        }|\n                        "
                    },
                    '/imported.st.css': {
                        namespace: 'imported',
                        content: ".importedPart {}"
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                // tslint:disable-next-line:max-line-length
                { message: stylable_transformer_1.transformerWarnings.SCOPE_PARAM_NOT_ROOT('importedPart'), file: '/entry.st.css', severity: 'error' }
            ]).meta;
            chai_1.expect(meta.outputAst.first.selector).to.equal('importedPart .entry--part');
        });
        it('should warn about scoping with a symbol that originates from a JS file', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        :import {\n                            -st-from: './imported.js';\n                            -st-named: someVar;\n                        }\n                        |@st-scope $someVar$ {\n                            .part {}\n                        }|\n                        "
                    },
                    '/imported.js': {
                        namespace: 'imported',
                        content: "\n                            module.exports = {\n                                someVar: 'someValue'\n                            }\n                        "
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                // tslint:disable-next-line:max-line-length
                { message: stylable_transformer_1.transformerWarnings.SCOPE_PARAM_NOT_CSS('someVar'), file: '/entry.st.css', severity: 'error' }
            ]).meta;
            chai_1.expect(meta.outputAst.first.selector).to.equal('someVar .entry--part');
        });
        it('should warn about a missing scoping parameter', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        |@st-scope {\n                            .part {}\n                        }|\n                        "
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                { message: src_1.processorWarnings.MISSING_SCOPING_PARAM(), file: '/entry.st.css', severity: 'warning' }
            ]).meta;
            chai_1.expect(meta.outputAst.first.selector).to.equal('.entry--part');
        });
        it('should warn about an unknown scoping parameter', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        |@st-scope $unknown$ {\n                            .part {}\n                        }|\n                        "
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                // tslint:disable-next-line:max-line-length
                { message: stylable_transformer_1.transformerWarnings.UNKNOWN_SCOPING_PARAM('unknown'), file: '/entry.st.css', severity: 'error' }
            ]).meta;
            chai_1.expect(meta.outputAst.first.selector).to.equal('unknown .entry--part');
        });
        it('should warn about vars definition inside a scope', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        @st-scope .root {\n                            |:vars {\n                                myColor: red;\n                            }|\n\n                            .part {}\n                        }\n                    "
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                { message: src_1.processorWarnings.NO_VARS_DEF_IN_ST_SCOPE(), file: '/entry.st.css', severity: 'warning' }
            ]).meta;
            chai_1.expect(meta.outputAst.first.selector).to.equal('.entry--root .entry--part');
        });
        it('should warn about import usage inside a scope', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        @st-scope .root {\n                            |:import {\n                                -st-from: \"imported.st.css\";\n                                -st-default: Comp;\n                            }|\n\n                            .part {}\n                        }\n                    "
                    }
                }
            };
            var meta = diagnostics_1.expectWarningsFromTransform(config, [
                { message: src_1.processorWarnings.NO_IMPORT_IN_ST_SCOPE(), file: '/entry.st.css', severity: 'warning' }
            ]).meta;
            chai_1.expect(meta.outputAst.first.selector).to.equal('.entry--root .entry--part');
        });
        it('should warn about @keyframe usage inside a scope', function () {
            var config = {
                entry: "/entry.st.css",
                files: {
                    '/entry.st.css': {
                        namespace: 'entry',
                        content: "\n                        @st-scope .root {\n                            |@keyframes frames {\n                                from {\n                                    margin: 100%;\n                                }\n                                to {\n                                    margin: 0%;\n                                }\n                            }|\n                        }\n                    "
                    }
                }
            };
            diagnostics_1.expectWarningsFromTransform(config, [
                { message: src_1.processorWarnings.NO_KEYFRAMES_IN_ST_SCOPE(), file: '/entry.st.css', severity: 'warning' }
            ]);
        });
    });
});
//# sourceMappingURL=scope-directive.spec.js.map