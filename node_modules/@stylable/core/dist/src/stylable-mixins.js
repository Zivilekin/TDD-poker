"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var postcss_1 = __importDefault(require("postcss"));
var functions_1 = require("./functions");
var parser_1 = require("./parser");
var stylable_assets_1 = require("./stylable-assets");
var stylable_utils_1 = require("./stylable-utils");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
/* tslint:disable:max-line-length */
exports.mixinWarnings = {
    FAILED_TO_APPLY_MIXIN: function (error) { return "could not apply mixin: " + error; },
    JS_MIXIN_NOT_A_FUNC: function () { return "js mixin must be a function"; },
    CIRCULAR_MIXIN: function (circularPaths) { return "circular mixin found: " + circularPaths.join(' --> '); },
    UNKNOWN_MIXIN_SYMBOL: function (name) { return "cannot mixin unknown symbol \"" + name + "\""; }
};
/* tslint:enable:max-line-length */
function appendMixins(transformer, rule, meta, variableOverride, path) {
    if (path === void 0) { path = []; }
    if (!rule.mixins || rule.mixins.length === 0) {
        return;
    }
    rule.mixins.forEach(function (mix) {
        appendMixin(mix, transformer, rule, meta, variableOverride, path);
    });
    rule.mixins.length = 0;
    rule.walkDecls(stylable_value_parsers_1.valueMapping.mixin, function (node) { return node.remove(); });
}
exports.appendMixins = appendMixins;
function appendMixin(mix, transformer, rule, meta, variableOverride, path) {
    if (path === void 0) { path = []; }
    if (checkRecursive(transformer, meta, mix, rule, path)) {
        return;
    }
    var local = meta.mappedSymbols[mix.mixin.type];
    if (local && (local._kind === 'class' || local._kind === 'element')) {
        handleLocalClassMixin(mix, transformer, meta, variableOverride, path, rule);
    }
    else {
        var resolvedMixin = transformer.resolver.resolve(mix.ref);
        if (resolvedMixin) {
            if (resolvedMixin._kind === 'js') {
                if (typeof resolvedMixin.symbol === 'function') {
                    try {
                        handleJSMixin(transformer, mix, resolvedMixin.symbol, meta, rule, variableOverride);
                    }
                    catch (e) {
                        transformer.diagnostics.error(rule, exports.mixinWarnings.FAILED_TO_APPLY_MIXIN(e), { word: mix.mixin.type });
                        return;
                    }
                }
                else {
                    transformer.diagnostics.error(rule, exports.mixinWarnings.JS_MIXIN_NOT_A_FUNC(), { word: mix.mixin.type });
                }
            }
            else {
                handleImportedCSSMixin(transformer, mix, rule, meta, path, variableOverride);
            }
        }
        else {
            // TODO: error cannot resolve mixin
        }
    }
}
exports.appendMixin = appendMixin;
function checkRecursive(transformer, meta, mix, rule, path) {
    var symbolName = mix.ref.name === meta.root ?
        mix.ref._kind === 'class' ?
            meta.root :
            'default' :
        mix.mixin.type;
    var isRecursive = path.indexOf(symbolName + ' from ' + meta.source) !== -1;
    if (isRecursive) {
        // Todo: add test verifying word
        transformer.diagnostics.warn(rule, exports.mixinWarnings.CIRCULAR_MIXIN(path), { word: symbolName });
        return true;
    }
    return false;
}
function handleJSMixin(transformer, mix, mixinFunction, meta, rule, variableOverride) {
    var res = mixinFunction(mix.mixin.options.map(function (v) { return v.value; }));
    var mixinRoot = parser_1.cssObjectToAst(res).root;
    mixinRoot.walkDecls(function (decl) {
        if (!stylable_utils_1.isValidDeclaration(decl)) {
            decl.value = String(decl);
        }
    });
    transformer.transformAst(mixinRoot, meta, undefined, variableOverride);
    stylable_assets_1.fixRelativeUrls(mixinRoot, mix, meta);
    stylable_utils_1.mergeRules(mixinRoot, rule);
}
function createMixinRootFromCSSResolve(transformer, mix, meta, resolvedClass, path, decl, variableOverride) {
    var isRootMixin = resolvedClass.symbol.name === resolvedClass.meta.root;
    var mixinRoot = stylable_utils_1.createSubsetAst(resolvedClass.meta.ast, (resolvedClass.symbol._kind === 'class' ? '.' : '') + resolvedClass.symbol.name, undefined, isRootMixin);
    var namedArgs = mix.mixin.options;
    var resolvedArgs = functions_1.resolveArgumentsValue(namedArgs, transformer, meta, transformer.diagnostics, decl, variableOverride, path);
    var mixinMeta = isRootMixin ? resolvedClass.meta : createInheritedMeta(resolvedClass);
    var symbolName = isRootMixin ?
        'default' :
        mix.mixin.type;
    transformer.transformAst(mixinRoot, mixinMeta, undefined, resolvedArgs, path.concat(symbolName + ' from ' + meta.source));
    stylable_assets_1.fixRelativeUrls(mixinRoot, mix, meta);
    return mixinRoot;
}
function handleImportedCSSMixin(transformer, mix, rule, meta, path, variableOverride) {
    var resolvedClass = transformer.resolver.resolve(mix.ref);
    var roots = [];
    while (resolvedClass && resolvedClass.symbol && resolvedClass._kind === 'css') {
        var mixinDecl = getMixinDeclaration(rule) || postcss_1.default.decl();
        roots.push(createMixinRootFromCSSResolve(transformer, mix, meta, resolvedClass, path, mixinDecl, variableOverride));
        if ((resolvedClass.symbol._kind === 'class' || resolvedClass.symbol._kind === 'element') &&
            !resolvedClass.symbol[stylable_value_parsers_1.valueMapping.extends]) {
            resolvedClass = transformer.resolver.resolve(resolvedClass.symbol);
        }
        else {
            break;
        }
    }
    if (roots.length === 1) {
        stylable_utils_1.mergeRules(roots[0], rule);
    }
    else if (roots.length > 1) {
        var mixinRoot_1 = postcss_1.default.root();
        roots.forEach(function (root) { return mixinRoot_1.prepend.apply(mixinRoot_1, root.nodes); });
        stylable_utils_1.mergeRules(mixinRoot_1, rule);
    }
    else {
        var mixinDecl = getMixinDeclaration(rule);
        if (mixinDecl) {
            transformer.diagnostics.error(mixinDecl, exports.mixinWarnings.UNKNOWN_MIXIN_SYMBOL(mixinDecl.value), { word: mixinDecl.value });
        }
    }
}
function handleLocalClassMixin(mix, transformer, meta, variableOverride, path, rule) {
    var isRootMixin = mix.ref.name === meta.root;
    var namedArgs = mix.mixin.options;
    var mixinDecl = getMixinDeclaration(rule) || postcss_1.default.decl();
    var resolvedArgs = functions_1.resolveArgumentsValue(namedArgs, transformer, meta, transformer.diagnostics, mixinDecl, variableOverride, path);
    var mixinRoot = stylable_utils_1.createSubsetAst(meta.ast, '.' + mix.ref.name, undefined, isRootMixin);
    transformer.transformAst(mixinRoot, isRootMixin ? meta : createInheritedMeta({ meta: meta, symbol: mix.ref, _kind: 'css' }), undefined, resolvedArgs, path.concat(mix.mixin.type + ' from ' + meta.source));
    stylable_utils_1.mergeRules(mixinRoot, rule);
}
function createInheritedMeta(resolvedClass) {
    var mixinMeta = Object.create(resolvedClass.meta);
    mixinMeta.parent = resolvedClass.meta;
    mixinMeta.mappedSymbols = Object.create(resolvedClass.meta.mappedSymbols);
    mixinMeta.mappedSymbols[resolvedClass.meta.root] = resolvedClass.meta.mappedSymbols[resolvedClass.symbol.name];
    return mixinMeta;
}
function getMixinDeclaration(rule) {
    return (rule.nodes && rule.nodes.find(function (node) {
        return node.type === 'decl' && node.prop === stylable_value_parsers_1.valueMapping.mixin;
    }));
}
//# sourceMappingURL=stylable-mixins.js.map