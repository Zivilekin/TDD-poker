"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
var functions_1 = require("./functions");
var native_reserved_lists_1 = require("./native-reserved-lists");
var path_1 = require("./path");
var pseudo_states_1 = require("./pseudo-states");
var selector_utils_1 = require("./selector-utils");
var stylable_mixins_1 = require("./stylable-mixins");
var stylable_resolver_1 = require("./stylable-resolver");
var stylable_utils_1 = require("./stylable-utils");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
var isVendorPrefixed = require('is-vendor-prefixed');
var valueParser = require('postcss-value-parser');
/* tslint:disable:max-line-length */
exports.transformerWarnings = {
    SYMBOL_IN_USE: function (name) { return "symbol '" + name + "' is already in use"; },
    UNKNOWN_PSEUDO_ELEMENT: function (name) { return "unknown pseudo element \"" + name + "\""; },
    IMPORT_ISNT_EXTENDABLE: function () { return 'import is not extendable'; },
    CANNOT_EXTEND_UNKNOWN_SYMBOL: function (name) { return "cannot extend unknown symbol \"" + name + "\""; },
    CANNOT_EXTEND_JS: function () { return 'JS import is not extendable'; },
    KEYFRAME_NAME_RESERVED: function (name) { return "keyframes \"" + name + "\" is reserved"; },
    UNKNOWN_IMPORT_ALIAS: function (name) { return "cannot use alias for unknown import \"" + name + "\""; },
    SCOPE_PARAM_NOT_ROOT: function (name) { return "\"@st-scope\" parameter \"" + name + "\" does not resolve to a stylesheet root"; },
    SCOPE_PARAM_NOT_CSS: function (name) { return "\"@st-scope\" parameter \"" + name + "\" must be a Stylable stylesheet, instead name originated from a JavaScript file"; },
    UNKNOWN_SCOPING_PARAM: function (name) { return "\"@st-scope\" received an unknown symbol: \"" + name + "\""; }
};
/* tslint:enable:max-line-length */
var StylableTransformer = /** @class */ (function () {
    function StylableTransformer(options) {
        this.diagnostics = options.diagnostics;
        this.delimiter = options.delimiter || '--';
        this.keepValues = options.keepValues || false;
        this.fileProcessor = options.fileProcessor;
        this.replaceValueHook = options.replaceValueHook;
        this.postProcessor = options.postProcessor;
        this.resolver = new stylable_resolver_1.StylableResolver(options.fileProcessor, options.requireModule);
        this.mode = options.mode || 'production';
    }
    StylableTransformer.prototype.transform = function (meta) {
        var metaExports = {};
        var ast = this.resetTransformProperties(meta);
        this.transformAst(ast, meta, metaExports);
        this.transformGlobals(ast, meta);
        meta.transformDiagnostics = this.diagnostics;
        var result = { meta: meta, exports: metaExports };
        return this.postProcessor ? this.postProcessor(result, this) : result;
    };
    StylableTransformer.prototype.transformAst = function (ast, meta, metaExports, variableOverride, path) {
        var _this = this;
        if (path === void 0) { path = []; }
        var keyframeMapping = this.scopeKeyframes(ast, meta);
        this.resolver.validateImports(meta, this.diagnostics);
        validateScopes(meta, this.resolver, this.diagnostics);
        ast.walkRules(function (rule) {
            if (selector_utils_1.isChildOfAtRule(rule, 'keyframes')) {
                return;
            }
            rule.selector = _this.scopeRule(meta, rule, metaExports);
        });
        ast.walkAtRules(/media$/, function (atRule) {
            atRule.params = functions_1.evalDeclarationValue(_this.resolver, atRule.params, meta, atRule, variableOverride, _this.replaceValueHook, _this.diagnostics, path.slice());
        });
        ast.walkDecls(function (decl) {
            stylable_utils_1.getDeclStylable(decl).sourceValue = decl.value;
            switch (decl.prop) {
                case stylable_value_parsers_1.valueMapping.mixin:
                    break;
                case stylable_value_parsers_1.valueMapping.states:
                    pseudo_states_1.validateStateDefinition(decl, meta, _this.resolver, _this.diagnostics);
                    break;
                default:
                    decl.value = functions_1.evalDeclarationValue(_this.resolver, decl.value, meta, decl, variableOverride, _this.replaceValueHook, _this.diagnostics, path.slice());
            }
        });
        ast.walkRules(function (rule) { return stylable_mixins_1.appendMixins(_this, rule, meta, variableOverride, path); });
        if (metaExports) {
            this.exportRootClass(meta, metaExports);
            this.exportLocalVars(meta, metaExports, variableOverride);
            this.exportKeyframes(keyframeMapping, metaExports);
        }
    };
    StylableTransformer.prototype.exportLocalVars = function (meta, metaExports, variableOverride) {
        var _this = this;
        meta.vars.forEach(function (varSymbol) {
            if (metaExports[varSymbol.name]) {
                _this.diagnostics.warn(varSymbol.node, exports.transformerWarnings.SYMBOL_IN_USE(varSymbol.name), { word: varSymbol.name });
            }
            else {
                metaExports[varSymbol.name] = functions_1.evalDeclarationValue(_this.resolver, varSymbol.text, meta, varSymbol.node, variableOverride);
            }
        });
    };
    StylableTransformer.prototype.exportKeyframes = function (keyframeMapping, metaExports) {
        var _this = this;
        Object.keys(keyframeMapping).forEach(function (name) {
            if (metaExports[name] === keyframeMapping[name].value) {
                _this.diagnostics.warn(keyframeMapping[name].node, exports.transformerWarnings.SYMBOL_IN_USE(name), { word: name });
            }
            else {
                metaExports[name] = keyframeMapping[name].value;
            }
        });
    };
    StylableTransformer.prototype.exportRootClass = function (meta, metaExports) {
        var classExports = {};
        this.handleClass(meta, {
            type: 'class',
            name: meta.mappedSymbols[meta.root].name,
            nodes: []
        }, meta.mappedSymbols[meta.root].name, classExports);
        metaExports[meta.root] = classExports[meta.mappedSymbols[meta.root].name];
    };
    StylableTransformer.prototype.exportClass = function (meta, name, classSymbol, metaExports) {
        var scopedName = this.scope(name, meta.namespace);
        if (metaExports && !metaExports[name]) {
            var extend = classSymbol ? classSymbol[stylable_value_parsers_1.valueMapping.extends] : undefined;
            var exportedClasses = scopedName;
            if (extend && extend !== classSymbol) {
                var finalSymbol = void 0;
                var finalName = void 0;
                var finalMeta = void 0;
                if (extend._kind === 'class') {
                    finalSymbol = extend;
                    finalName = extend.name;
                    finalMeta = meta;
                }
                else if (extend._kind === 'import') {
                    var resolved = this.resolver.deepResolve(extend);
                    var found = stylable_utils_1.findRule(meta.ast, '.' + classSymbol.name);
                    if (resolved && resolved._kind === 'css' && resolved.symbol) {
                        if (resolved.symbol._kind === 'class') {
                            finalSymbol = resolved.symbol;
                            finalName = resolved.symbol.name;
                            finalMeta = resolved.meta;
                        }
                        else {
                            if (!!found) {
                                this.diagnostics.error(found, exports.transformerWarnings.IMPORT_ISNT_EXTENDABLE(), { word: found.value });
                            }
                        }
                    }
                    else if (found && resolved) {
                        if (!resolved.symbol) {
                            var importNode = stylable_utils_1.findDeclaration(extend.import, function (node) { return node.prop === stylable_value_parsers_1.valueMapping.named; });
                            this.diagnostics.error(found, exports.transformerWarnings.CANNOT_EXTEND_UNKNOWN_SYMBOL(found.value), { word: found.value });
                        }
                        else {
                            this.diagnostics.error(found, exports.transformerWarnings.CANNOT_EXTEND_JS(), { word: found.value });
                        }
                    }
                }
                if (finalSymbol && finalName && finalMeta && !finalSymbol[stylable_value_parsers_1.valueMapping.root]) {
                    var classExports = {};
                    this.handleClass(finalMeta, { type: 'class', name: finalName, nodes: [] }, finalName, classExports);
                    if (classExports[finalName]) {
                        exportedClasses += ' ' + classExports[finalName];
                    }
                    else {
                        console.error("something went wrong when exporting '" + finalName + "', " +
                            "please file an issue in stylable. With specific use case");
                    }
                }
            }
            metaExports[name] = exportedClasses;
        }
        return scopedName;
    };
    StylableTransformer.prototype.scopeKeyframes = function (ast, meta) {
        var _this = this;
        var keyframesExports = {};
        ast.walkAtRules(/keyframes$/, function (atRule) {
            var name = atRule.params;
            if (!!~native_reserved_lists_1.reservedKeyFrames.indexOf(name)) {
                _this.diagnostics.error(atRule, exports.transformerWarnings.KEYFRAME_NAME_RESERVED(name), { word: name });
            }
            if (!keyframesExports[name]) {
                keyframesExports[name] = {
                    value: _this.scope(name, meta.namespace),
                    node: atRule
                };
            }
            atRule.params = keyframesExports[name].value;
        });
        ast.walkDecls(/animation$|animation-name$/, function (decl) {
            var parsed = valueParser(decl.value);
            parsed.nodes.forEach(function (node) {
                var alias = keyframesExports[node.value] && keyframesExports[node.value].value;
                if (node.type === 'word' && Boolean(alias)) {
                    node.value = alias;
                }
            });
            decl.value = parsed.toString();
        });
        return keyframesExports;
    };
    StylableTransformer.prototype.addGlobalsToMeta = function (selectorAst, meta) {
        if (!meta) {
            return;
        }
        for (var _i = 0, selectorAst_1 = selectorAst; _i < selectorAst_1.length; _i++) {
            var ast = selectorAst_1[_i];
            selector_utils_1.traverseNode(ast, function (inner) {
                if (inner.type === 'class') {
                    meta.globals[inner.name] = true;
                }
            });
        }
    };
    StylableTransformer.prototype.transformGlobals = function (ast, meta) {
        var _this = this;
        ast.walkRules(function (r) {
            var selectorAst = selector_utils_1.parseSelector(r.selector);
            selector_utils_1.traverseNode(selectorAst, function (node) {
                if (node.type === 'nested-pseudo-class' && node.name === 'global') {
                    _this.addGlobalsToMeta([node], meta);
                    node.type = 'selector';
                    return true;
                }
                return undefined;
            });
            // this.addGlobalsToMeta([selectorAst], meta);
            r.selector = selector_utils_1.stringifySelector(selectorAst);
        });
    };
    StylableTransformer.prototype.resolveSelectorElements = function (meta, selector) {
        return this.scopeSelector(meta, selector, undefined, true).elements;
    };
    StylableTransformer.prototype.scopeSelector = function (originMeta, selector, metaExports, calcPaths, rule) {
        var _this = this;
        if (calcPaths === void 0) { calcPaths = false; }
        var meta = originMeta;
        var current = meta;
        var symbol = null;
        var nestedSymbol;
        var originSymbol;
        var selectorAst = selector_utils_1.parseSelector(selector);
        var addedSelectors = [];
        var elements = selectorAst.nodes.map(function (selectorNode) {
            var selectorElements = [];
            selector_utils_1.traverseNode(selectorNode, function (node) {
                var name = node.name, type = node.type;
                if (calcPaths && (type === 'class' || type === 'element' || type === 'pseudo-element')) {
                    selectorElements.push({
                        name: name,
                        type: type,
                        resolved: _this.resolver.resolveExtends(current, name, type === 'element', _this)
                    });
                }
                if (type === 'selector' || type === 'spacing' || type === 'operator') {
                    if (nestedSymbol) {
                        symbol = nestedSymbol;
                        nestedSymbol = null;
                    }
                    else {
                        meta = originMeta;
                        current = originMeta;
                        symbol = originMeta.classes[originMeta.root];
                        originSymbol = symbol;
                    }
                }
                else if (type === 'class') {
                    var next = _this.handleClass(current, node, name, metaExports, rule, originMeta);
                    originSymbol = current.classes[name];
                    symbol = next.symbol;
                    current = next.meta;
                }
                else if (type === 'element') {
                    var next = _this.handleElement(current, node, name, originMeta);
                    originSymbol = current.elements[name];
                    symbol = next.symbol;
                    current = next.meta;
                }
                else if (type === 'pseudo-element') {
                    var next = _this.handlePseudoElement(current, node, name, selectorNode, addedSelectors, rule, originMeta);
                    originSymbol = current.classes[name];
                    meta = current;
                    symbol = next.symbol;
                    current = next.meta;
                }
                else if (type === 'pseudo-class') {
                    current = pseudo_states_1.transformPseudoStateSelector(current, node, name, symbol, meta, originSymbol, _this.resolver, _this.diagnostics, rule);
                }
                else if (type === 'nested-pseudo-class') {
                    if (name === 'global') {
                        // node.type = 'selector';
                        return true;
                    }
                    nestedSymbol = symbol;
                }
                else if (type === 'invalid' && node.value === '&' && current.parent) {
                    var origin_1 = current.mappedSymbols[current.root];
                    var next = _this.handleClass(current, {
                        type: 'class',
                        nodes: [],
                        name: origin_1.name
                    }, origin_1.name, undefined, undefined, originMeta);
                    originSymbol = current.classes[origin_1.name];
                    symbol = next.symbol;
                    current = next.meta;
                }
                /* do nothing */
                return undefined;
            });
            return selectorElements;
        });
        this.addAdditionalSelectors(addedSelectors, selectorAst);
        return {
            current: current,
            symbol: symbol,
            selectorAst: selectorAst,
            elements: elements,
            selector: selector_utils_1.stringifySelector(selectorAst)
        };
    };
    StylableTransformer.prototype.addAdditionalSelectors = function (addedSelectors, selectorAst) {
        addedSelectors.forEach(function (s) {
            var clone = lodash_clonedeep_1.default(s.selectorNode);
            var i = s.selectorNode.nodes.indexOf(s.node);
            if (i === -1) {
                throw new Error('not supported inside nested classes');
            }
            else {
                clone.nodes[i].value = s.customElementChunk;
            }
            selectorAst.nodes.push(clone);
        });
    };
    StylableTransformer.prototype.applyRootScoping = function (meta, selectorAst) {
        var scopedRoot = meta.mappedSymbols[meta.root][stylable_value_parsers_1.valueMapping.global] ||
            this.scope(meta.root, meta.namespace);
        selectorAst.nodes.forEach(function (selector) {
            var first = selector.nodes[0];
            /* This finds a transformed or non transform global selector */
            if (first &&
                (first.type === 'selector' || first.type === 'nested-pseudo-class') &&
                first.name === 'global') {
                return;
            }
            // -st-global can make anther global inside root
            if (first && first.nodes === scopedRoot) {
                return;
            }
            if (first && first.before && first.before === '.' + scopedRoot) {
                return;
            }
            if (first && first.type === 'invalid' && first.value === '&') {
                return;
            }
            if (!first || (first.name !== scopedRoot)) {
                selector.nodes = [
                    typeof scopedRoot !== 'string' ?
                        { type: 'selector', nodes: scopedRoot, name: 'global' } :
                        { type: 'class', name: scopedRoot, nodes: [] },
                    { type: 'spacing', value: ' ', name: '', nodes: [] }
                ].concat(selector.nodes);
            }
        });
    };
    StylableTransformer.prototype.scopeRule = function (meta, rule, metaExports) {
        return this.scopeSelector(meta, rule.selector, metaExports, false, rule).selector;
    };
    StylableTransformer.prototype.handleClass = function (meta, node, name, metaExports, rule, originMeta) {
        var symbol = meta.classes[name];
        var extend = symbol ? symbol[stylable_value_parsers_1.valueMapping.extends] : undefined;
        if (!extend && symbol && symbol.alias) {
            var next_1 = this.resolver.deepResolve(symbol.alias);
            if (next_1 && next_1._kind === 'css' && next_1.symbol && next_1.symbol._kind === 'class') {
                var globalMappedNodes_1 = next_1.symbol[stylable_value_parsers_1.valueMapping.global];
                if (globalMappedNodes_1) {
                    node.before = '';
                    node.type = 'selector';
                    node.nodes = globalMappedNodes_1;
                    this.addGlobalsToMeta(globalMappedNodes_1, originMeta);
                }
                else {
                    node.name = this.exportClass(next_1.meta, next_1.symbol.name, next_1.symbol, metaExports);
                }
                if (next_1.symbol[stylable_value_parsers_1.valueMapping.extends]) {
                    next_1 = this.resolver.deepResolve(next_1.symbol[stylable_value_parsers_1.valueMapping.extends]);
                    if (next_1 && next_1._kind === 'css') {
                        return next_1;
                    }
                }
                else {
                    return next_1;
                }
            }
            else if (rule) {
                this.diagnostics.error(rule, exports.transformerWarnings.UNKNOWN_IMPORT_ALIAS(name), { word: symbol.alias.name });
            }
        }
        var scopedName = '';
        var globalScopedSelector = '';
        var globalMappedNodes = symbol && symbol[stylable_value_parsers_1.valueMapping.global];
        if (globalMappedNodes) {
            globalScopedSelector = selector_utils_1.stringifySelector({ type: 'selector', name: '', nodes: globalMappedNodes });
        }
        else {
            scopedName = this.exportClass(meta, name, symbol, metaExports);
        }
        if (globalScopedSelector) {
            node.before = '';
            node.type = 'selector';
            node.nodes = symbol[stylable_value_parsers_1.valueMapping.global] || [];
            this.addGlobalsToMeta(globalMappedNodes, originMeta);
        }
        else {
            node.name = scopedName;
        }
        var next = this.resolver.deepResolve(extend);
        if (next && next._kind === 'css' && next.symbol && next.symbol._kind === 'class') {
            if (this.mode === 'development' && rule && rule.selectorType === 'class') {
                rule.after(selector_utils_1.createWarningRule(next.symbol.name, this.scope(next.symbol.name, next.meta.namespace), path_1.basename(next.meta.source), name, this.scope(symbol.name, meta.namespace), path_1.basename(meta.source)));
            }
            return next;
        }
        // local
        if (extend && extend._kind === 'class') {
            if (extend === symbol && extend.alias) {
                var next_2 = this.resolver.deepResolve(extend.alias);
                if (next_2 && next_2._kind === 'css' && next_2.symbol) {
                    return next_2;
                }
            }
        }
        return { _kind: 'css', meta: meta, symbol: symbol };
    };
    StylableTransformer.prototype.handleElement = function (meta, node, name, originMeta) {
        var tRule = meta.elements[name];
        var extend = tRule ? meta.mappedSymbols[name] : undefined;
        var next = this.resolver.deepResolve(extend);
        if (next && next._kind === 'css' && next.symbol) {
            if (next.symbol._kind === 'class' && next.symbol[stylable_value_parsers_1.valueMapping.global]) {
                node.before = '';
                node.type = 'selector';
                node.nodes = next.symbol[stylable_value_parsers_1.valueMapping.global] || [];
                this.addGlobalsToMeta(node.nodes, originMeta);
            }
            else {
                node.type = 'class';
                node.name = this.scope(next.symbol.name, next.meta.namespace);
            }
            // node.name = (next.symbol as ClassSymbol)[valueMapping.global] ||
            //             this.scope(next.symbol.name, next.meta.namespace);
            return next;
        }
        return { meta: meta, symbol: tRule };
    };
    StylableTransformer.prototype.handlePseudoElement = function (meta, node, name, selectorNode, addedSelectors, rule, originMeta) {
        var next;
        var customSelector = meta.customSelectors[':--' + name];
        if (customSelector) {
            var rootRes = this.scopeSelector(meta, '.root', {}, false);
            var res = this.scopeSelector(meta, customSelector, {}, false);
            var rootEg_1 = new RegExp('^\\s*' + rootRes.selector.replace(/\./, '\\.') + '\\s*');
            var selectors = res.selectorAst.nodes.map(function (sel) { return selector_utils_1.stringifySelector(sel).trim().replace(rootEg_1, ''); });
            if (selectors[0]) {
                node.type = 'invalid'; /*just take it */
                node.before = ' ';
                node.value = selectors[0];
            }
            for (var i = 1 /*start from second one*/; i < selectors.length; i++) {
                addedSelectors.push({
                    selectorNode: selectorNode,
                    node: node,
                    customElementChunk: selectors[i]
                });
            }
            if (res.selectorAst.nodes.length === 1 && res.symbol) {
                return { _kind: 'css', meta: res.current, symbol: res.symbol };
            }
            // this is an error mode fallback
            return { _kind: 'css', meta: meta, symbol: { _kind: 'element', name: '*' } };
        }
        // find if the current symbol exsists in the initial meta;
        var symbol = meta.mappedSymbols[name];
        var current = meta;
        while (!symbol) {
            // go up the root extends path and find first symbol
            var root = current.mappedSymbols[current.root];
            next = this.resolver.deepResolve(root[stylable_value_parsers_1.valueMapping.extends]);
            if (next && next._kind === 'css') {
                current = next.meta;
                symbol = next.meta.mappedSymbols[name];
            }
            else {
                break;
            }
        }
        if (symbol) {
            if (symbol._kind === 'class') {
                node.type = 'class';
                node.before = symbol[stylable_value_parsers_1.valueMapping.root] ? '' : ' ';
                next = this.resolver.deepResolve(symbol);
                if (symbol[stylable_value_parsers_1.valueMapping.global]) {
                    node.type = 'selector';
                    node.nodes = symbol[stylable_value_parsers_1.valueMapping.global] || [];
                    this.addGlobalsToMeta(node.nodes, originMeta);
                }
                else {
                    if (symbol.alias && !symbol[stylable_value_parsers_1.valueMapping.extends]) {
                        if (next && next.meta && next.symbol) {
                            node.name = this.scope(next.symbol.name, next.meta.namespace);
                        }
                        else {
                            // TODO: maybe warn on un resolved alias
                        }
                    }
                    else {
                        node.name = this.scope(symbol.name, current.namespace);
                    }
                }
                if (next && next._kind === 'css') {
                    return next;
                }
            }
        }
        else if (rule) {
            if (native_reserved_lists_1.nativePseudoElements.indexOf(name) === -1 && !isVendorPrefixed(name)) {
                this.diagnostics.warn(rule, exports.transformerWarnings.UNKNOWN_PSEUDO_ELEMENT(name), { word: name });
            }
        }
        return { _kind: 'css', meta: current, symbol: symbol };
    };
    StylableTransformer.prototype.cssStates = function (stateMapping, namespace) {
        return stateMapping ? Object.keys(stateMapping).reduce(function (states, key) {
            if (stateMapping[key]) {
                states[pseudo_states_1.autoStateAttrName(key, namespace)] = true;
            }
            return states;
        }, {}) : {};
    };
    StylableTransformer.prototype.scope = function (name, namespace, delimiter) {
        if (delimiter === void 0) { delimiter = this.delimiter; }
        return namespace ? namespace + delimiter + name : name;
    };
    StylableTransformer.prototype.resetTransformProperties = function (meta) {
        meta.globals = {};
        return meta.outputAst = meta.ast.clone();
    };
    return StylableTransformer;
}());
exports.StylableTransformer = StylableTransformer;
function removeSTDirective(root) {
    var toRemove = [];
    root.walkRules(function (rule) {
        if (rule.nodes && rule.nodes.length === 0) {
            toRemove.push(rule);
            return;
        }
        rule.walkDecls(function (decl) {
            if (decl.prop.startsWith('-st-')) {
                toRemove.push(decl);
            }
        });
        if (rule.raws) {
            rule.raws = {
                after: '\n'
            };
        }
    });
    if (root.raws) {
        root.raws = {};
    }
    function removeRecursiveUpIfEmpty(node) {
        var parent = node.parent;
        node.remove();
        if (parent && parent.nodes && parent.nodes.length === 0) {
            removeRecursiveUpIfEmpty(parent);
        }
    }
    toRemove.forEach(function (node) {
        removeRecursiveUpIfEmpty(node);
    });
}
exports.removeSTDirective = removeSTDirective;
function validateScopes(meta, resolver, diagnostics) {
    for (var _i = 0, _a = meta.scopes; _i < _a.length; _i++) {
        var scope = _a[_i];
        var name_1 = scope.params.startsWith('.') ? scope.params.slice(1) : scope.params;
        if (!name_1) {
            continue;
        }
        else if (!meta.mappedSymbols[name_1]) {
            diagnostics.error(scope, exports.transformerWarnings.UNKNOWN_SCOPING_PARAM(scope.params), { word: scope.params });
            continue;
        }
        var resolvedScope = resolver.deepResolve(meta.mappedSymbols[name_1]);
        if (resolvedScope && resolvedScope._kind === 'css') {
            var scopingMeta = resolvedScope.meta, scopingSymbol = resolvedScope.symbol;
            if (scopingSymbol.name !== scopingMeta.root) {
                diagnostics.error(scope, exports.transformerWarnings.SCOPE_PARAM_NOT_ROOT(scope.params), { word: scope.params });
            }
        }
        else if (resolvedScope && resolvedScope._kind === 'js') {
            diagnostics.error(scope, exports.transformerWarnings.SCOPE_PARAM_NOT_CSS(scope.params), { word: scope.params });
        }
        else if (meta.classes[name_1] || meta.elements[scope.params] && meta.elements[scope.params].alias) {
            // do nothing valid input
        }
        else {
            diagnostics.error(scope, exports.transformerWarnings.UNKNOWN_SCOPING_PARAM(scope.params), { word: scope.params });
        }
    }
}
//# sourceMappingURL=stylable-transformer.js.map