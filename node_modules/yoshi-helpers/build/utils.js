"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripOrganization = exports.readJsonSilent = exports.killSpawnProcessAndHisChildren = exports.getProjectCDNBasePath = exports.getProjectArtifactVersion = exports.getProjectArtifactId = exports.tryRequire = exports.toIdentifier = exports.getProcessOnPort = exports.processIsJest = exports.getProcessIdOnPort = exports.shouldTransformHMRRuntime = exports.getListOfEntries = exports.getMochaReporter = exports.watch = exports.writeFile = exports.reportWebpackStats = exports.suffix = exports.logIfAny = void 0;
const path_1 = __importDefault(require("path"));
const child_process_1 = __importDefault(require("child_process"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const chokidar_1 = __importDefault(require("chokidar"));
const chalk_1 = __importDefault(require("chalk"));
const ps_tree_1 = __importDefault(require("ps-tree"));
const detect_port_1 = __importDefault(require("detect-port"));
const yoshi_config_1 = __importDefault(require("yoshi-config"));
const paths_1 = require("yoshi-config/build/paths");
const xmldoc_1 = __importDefault(require("xmldoc"));
const queries_1 = require("./queries");
const constants_1 = require("./constants");
function logIfAny(log) {
    if (log) {
        console.log(log);
    }
}
exports.logIfAny = logIfAny;
exports.suffix = (ending) => (str) => {
    const hasSuffix = str.lastIndexOf(ending) === str.length - ending.length;
    return hasSuffix ? str : str + ending;
};
exports.reportWebpackStats = (buildType, stats) => {
    console.log(chalk_1.default.magenta(`Webpack summary for ${buildType} build:`));
    logIfAny(stats.toString({
        colors: true,
        hash: false,
        chunks: false,
        assets: true,
        children: false,
        version: false,
        timings: false,
        modules: false,
        entrypoints: false,
        warningsFilter: /export .* was not found in/,
        builtAt: false,
    }));
};
exports.writeFile = (targetFileName, data) => {
    mkdirp_1.default.sync(path_1.default.dirname(targetFileName));
    fs_extra_1.default.writeFileSync(path_1.default.resolve(targetFileName), data);
};
exports.watch = (_a, callback) => {
    var { pattern, cwd = process.cwd(), ignoreInitial = true } = _a, options = __rest(_a, ["pattern", "cwd", "ignoreInitial"]);
    const watcher = chokidar_1.default
        .watch(pattern, Object.assign({ cwd, ignoreInitial }, options))
        .on('all', (event, filePath) => callback(filePath));
    return watcher;
};
exports.getMochaReporter = () => {
    if (queries_1.inTeamCity()) {
        return 'mocha-teamcity-reporter';
    }
    if (process.env.mocha_reporter) {
        return process.env.mocha_reporter;
    }
    return 'progress';
};
exports.getListOfEntries = (entry) => {
    if (typeof entry === 'string') {
        return [path_1.default.resolve('src', entry)];
    }
    else if (typeof entry === 'object') {
        return Object.keys(entry).map(name => {
            const file = entry[name];
            return path_1.default.resolve('src', file);
        });
    }
    return [];
};
exports.shouldTransformHMRRuntime = () => {
    return yoshi_config_1.default.hmr === 'auto' && yoshi_config_1.default.isReactProject;
};
exports.getProcessIdOnPort = (port) => {
    return child_process_1.default
        .execSync(`lsof -i:${port} -P -t -sTCP:LISTEN`, { encoding: 'utf-8' })
        .toString()
        .split('\n')[0]
        .trim();
};
const getDirectoryOfProcessById = (pid) => {
    return child_process_1.default
        .execSync(`lsof -p ${pid} | grep cwd | awk '{print substr($0, index($0,$9))}'`, {
        encoding: 'utf-8',
    })
        .toString()
        .trim();
};
const getCommandArgByPid = (pid, argIndex = 0) => {
    return child_process_1.default
        .execSync(`ps -p ${pid} | awk '{print $${4 + argIndex}}'`, {
        encoding: 'utf-8',
    })
        .toString()
        .trim();
};
exports.processIsJest = (pid) => {
    const commandArg = getCommandArgByPid(pid, 1);
    return commandArg.split('/').pop() === 'jest';
};
exports.getProcessOnPort = async (port, shouldCheckTestResult) => {
    if (shouldCheckTestResult) {
        const portTestResult = await detect_port_1.default(port);
        if (port === portTestResult) {
            return null;
        }
    }
    try {
        const pid = exports.getProcessIdOnPort(port);
        const cwd = getDirectoryOfProcessById(parseInt(pid, 10));
        return {
            pid,
            cwd,
        };
    }
    catch (e) {
        return null;
    }
};
exports.toIdentifier = (str) => {
    const IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/;
    const IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g;
    return str
        .replace(IDENTIFIER_NAME_REPLACE_REGEX, '_$1')
        .replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, '_');
};
exports.tryRequire = (name) => {
    let absolutePath;
    try {
        absolutePath = require.resolve(name);
    }
    catch (e) {
        // The module has not found
        return null;
    }
    return require(absolutePath);
};
// Gets the artifact id of the project at the current working dir
exports.getProjectArtifactId = (cwd = process.cwd()) => {
    if (fs_extra_1.default.existsSync(path_1.default.join(cwd, paths_1.POM_FILE))) {
        const content = fs_extra_1.default.readFileSync(path_1.default.join(cwd, paths_1.POM_FILE), 'utf-8');
        const artifactId = new xmldoc_1.default.XmlDocument(content).valueWithPath('artifactId');
        return artifactId;
    }
    return '';
};
exports.getProjectArtifactVersion = () => {
    return (process.env.ARTIFACT_VERSION
        ? // Dev CI
            process.env.ARTIFACT_VERSION.replace('-SNAPSHOT', '')
        : // PR CI won't have a version, only SRC_MD5
            process.env.SRC_MD5);
};
// Gets the CDN base path for the project at the current working dir
exports.getProjectCDNBasePath = (useUnversionedBaseUrl) => {
    const artifactName = exports.getProjectArtifactId();
    let artifactPath = '';
    if (useUnversionedBaseUrl) {
        // Not to be confused with Yoshi's `dist` directory.
        //
        // Static assets are deployed to two locations on the CDN:
        //
        // - `https://static.parastorage.com/services/service-name/dist/asset.f43a1.js`
        // - `https://static.parastorage.com/services/service-name/1.2.3/asset.js`
        //
        // If this experimental feature is enabled, we can benefit from better caching by configuring
        // Webpack's `publicUrl` to use the first option.
        artifactPath = 'dist';
    }
    else {
        artifactPath = exports.getProjectArtifactVersion();
    }
    return `${constants_1.staticsDomain}/${artifactName}/${artifactPath}/`;
};
exports.killSpawnProcessAndHisChildren = (child) => {
    return new Promise(resolve => {
        if (!child) {
            return resolve();
        }
        const pid = child.pid;
        ps_tree_1.default(pid, (err, children) => {
            [pid]
                .concat(children.map(p => parseInt(p.PID, 10)))
                .forEach((tpid) => {
                try {
                    process.kill(tpid, 'SIGKILL');
                }
                catch (e) { }
            });
            resolve();
        });
    });
};
exports.readJsonSilent = (jsonPath) => !fs_extra_1.default.existsSync(jsonPath) ? {} : fs_extra_1.default.readJSONSync(jsonPath);
exports.stripOrganization = (name) => name.slice(name.indexOf('/') + 1);
//# sourceMappingURL=utils.js.map