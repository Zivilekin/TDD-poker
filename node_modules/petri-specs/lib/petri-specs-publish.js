const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');
const chalk = require('chalk');
const readDirectory = require('./utils/read-directory');
const relativeToRoot = require('../lib/utils/relative-to-root');
const validateSpec = require('./utils/validations');
const { GATEWAY_URL } = require('./utils/const');
const {
  clean,
  get,
  getModifiedSpecs,
  updateHashes,
} = require('../lib/utils/hash');

module.exports = async function(
  { isDryRun, specsPath, force, isVerbose } = {},
  logError = console.error,
) {
  const computedSpecsPath = path.join(
    specsPath || relativeToRoot('petri-specs'),
  );

  if (force) {
    clean(computedSpecsPath);
  }

  const filePaths = readDirectory(computedSpecsPath).filter(file =>
    file.endsWith('.json'),
  );

  isVerbose &&
    console.log(
      `
  ${chalk.bold.cyan.underline('Found the following spec files:')}
  ${filePaths
    .map(filePath => path.basename(filePath).replace(/\.json$/, ''))
    .join('\n')}
    `,
    );

  const invalidations = [];
  const validSpecs = [];

  filePaths.forEach(filePath => {
    const specFile = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    Object.entries(specFile).forEach(([key, data]) => {
      if (validateSpec(data)) {
        validSpecs.push({
          key,
          ...data,
        });
      } else {
        invalidations.push(key);
      }
    });
  });

  isVerbose &&
    console.log(
      `${chalk.bold.green.underline('Found the following specs valid:')}

      ${validSpecs
        .map(
          ({ name, data }) =>
            `${chalk.magenta(name)}
      ${JSON.stringify(data)}`,
        )
        .join('\n')},
    `,
    );

  if (invalidations.length) {
    logError(`
    ${chalk.red('Found the following specs invalid:')}
    ${invalidations.map(invalidation => `${invalidation}\n`)}
    Please fix them and try again.
    `);
    return;
  }

  const hashes = get(computedSpecsPath);
  const modifiedSpecs = getModifiedSpecs(hashes, validSpecs);
  if (!modifiedSpecs.length) {
    console.log(chalk.green('ðŸ‘Œ No modified specs found'));
    return;
  }
  const specsReadyToPublish = prepareSpecsForPublish(modifiedSpecs);
  console.log(
    `modifed specs to be published:\n ${specsReadyToPublish
      .map(readySpec => readySpec.key)
      .join('\n ')}`,
  );

  if (isDryRun) {
    console.log(
      chalk.green('ðŸŒµ Finish dry run. No specs have been created/updated'),
    );
    return;
  }

  const result = await publishSpecs(specsReadyToPublish);
  if (result.success) {
    updateHashes(hashes, modifiedSpecs, computedSpecsPath);
    console.log(chalk.green('ðŸ‘Œ Publish is complete'));
    return;
  } else {
    console.log(chalk.red(`Publish failed!`));
    logError(chalk.red(result.message));
  }
};

function prepareSpecsForPublish(specs) {
  const createDate = new Date();

  return specs.map(spec => {
    return {
      key: spec.key,
      owner: spec.owner,
      controlGroup: spec.controlGroup,
      variants: spec.variants,
      scopes: spec.scopes.map(scope => ({
        name: scope,
        onlyForLoggedInUsers: spec.onlyForLoggedInUsers,
      })),
      testGroups: [],
      creationDate: createDate,
      updateDate: createDate,
      persistent: spec.persistent || true,
      allowedForBots: spec.allowedForBots || false,
    };
  });
}

async function publishSpecs(data) {
  const result = {
    success: false,
    message: '',
  };

  try {
    const response = await fetch(`${GATEWAY_URL}/addSpecs`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    const responseContent = await response.json();
    if (response.status === 200 && responseContent.success) {
      result.success = true;
    } else {
      result.message = `Something Went Wrong, please talk to Fed-Infra\n\n${JSON.stringify(
        responseContent.message,
        null,
        2,
      )}`;
    }
  } catch (e) {
    result.message = `Error reaching the server. Make sure you're connected to Wix network or VPN. ${e.message}`;
  }

  return result;
}
