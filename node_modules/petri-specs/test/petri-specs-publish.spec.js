const { spec: buildSpec } = require('./testkit');

const fs = require('fs-extra');
const path = require('path');
const os = require('os');
const { expect } = require('chai');
const proxyquire = require('proxyquire');
const sinon = require('sinon');
const cliTest = require('./cli-test');
const { GATEWAY_URL } = require('../lib/utils/const');
const { get: getHashes } = require('../lib/utils/hash');

const createDefaultFetchStub = () =>
  sinon.stub().returns(
    Promise.resolve({
      status: 200,
      json: () => Promise.resolve({ success: true }),
    }),
  );

const generateSpecsPath = () =>
  path.join(os.tmpdir(), Date.now().toString(), 'petri-specs');

const createSpecFile = async (specsDirectory, key, fn) => {
  const filename = `${key}.json`;
  await fs.ensureDir(specsDirectory);
  fs.writeFileSync(
    path.join(specsDirectory, filename),
    JSON.stringify(buildSpec(key, fn)),
  );
};

const createPublishCommandTestKit = customizedFetchStub => {
  const that = this;
  const logError = sinon.stub();
  const fetchStub = customizedFetchStub || createDefaultFetchStub();
  const specDir = generateSpecsPath();
  const publishCommand = proxyquire('../lib/petri-specs-publish', {
    'node-fetch': fetchStub,
  });

  const given = {
    spec: async (key, fn) => {
      await createSpecFile(specDir, key, fn);
      return that;
    },
  };

  const when = {
    publish: async args => {
      await publishCommand({ ...args, specsPath: specDir }, logError);

      return that;
    },
  };

  const get = {
    specsHashes: () => getHashes(specDir),
    fetchStub,
    urlIsCorrect: () =>
      fetchStub.getCalls().pop().args[0] === `${GATEWAY_URL}/addSpecs`,
    keysPassedToServer: () => {
      const body = JSON.parse(fetchStub.getCalls().pop().args[1].body);
      return body.map(spec => spec.key);
    },
    lastError: () => logError.getCalls().pop().args[0],
  };

  return { get, given, when };
};

describe('petri-specs-publish', () => {
  let test;
  let testkit;

  beforeEach(() => {
    test = cliTest.create(require.resolve('../bin/petri-specs.js'));
    testkit = createPublishCommandTestKit();
  });

  afterEach(() => {
    test.teardown();
  });

  it('should update two spec files', async () => {
    await testkit.given.spec('spec.test1');
    await testkit.given.spec('spec.test2');
    await testkit.when.publish();

    expect(testkit.get.urlIsCorrect()).to.be.true;
    expect(testkit.get.keysPassedToServer()).to.eqls([
      'spec.test1',
      'spec.test2',
    ]);

    expect(testkit.get.specsHashes()).to.eqls({
      'spec.test1': 3432936641,
      'spec.test2': 3860210210,
    });
  });

  it('should present an error and not doing anything if an invalid spec is found', async () => {
    await testkit.given.spec('spec.test1');
    await testkit.given.spec('spec.test2', () => ({ owner: '' }));
    await testkit.when.publish();

    expect(testkit.get.lastError()).to.include(
      'Found the following specs invalid',
    );
    expect(testkit.get.fetchStub.getCalls().length).to.eq(0);
  });

  it('should not update if no change', async () => {
    await testkit.given.spec('spec.test1');
    await testkit.given.spec('spec.test2');
    await testkit.when.publish();
    await testkit.when.publish();

    expect(testkit.get.fetchStub.getCalls().length).to.eq(1);
  });

  it('should update if no changes but called with Force flag', async () => {
    await testkit.given.spec('spec.test1');
    await testkit.given.spec('spec.test2');
    await testkit.when.publish();
    await testkit.when.publish({ force: true });

    expect(testkit.get.fetchStub.getCalls().length).to.eq(2);
    expect(testkit.get.keysPassedToServer()).to.eqls([
      'spec.test1',
      'spec.test2',
    ]);
    expect(testkit.get.specsHashes()).to.eqls({
      'spec.test1': 3432936641,
      'spec.test2': 3860210210,
    });
  });

  it('should update 3rd spec after publish', async () => {
    await testkit.given.spec('spec.test1');
    await testkit.given.spec('spec.test2');
    await testkit.when.publish();

    await testkit.given.spec('spec.test3');
    await testkit.when.publish();

    expect(testkit.get.urlIsCorrect()).to.be.true;
    expect(testkit.get.keysPassedToServer()).to.eqls(['spec.test3']);

    expect(testkit.get.specsHashes()).to.eqls({
      'spec.test1': 3432936641,
      'spec.test2': 3860210210,
      'spec.test3': 3923936003,
    });
  });

  it('should not publish in dry run mode', async () => {
    await testkit.given.spec('spec.test1');
    await testkit.given.spec('spec.test2');
    await testkit.when.publish({ isDryRun: true });

    expect(testkit.get.fetchStub.getCalls().length).to.eq(0);
  });

  it('should return an error if something bad happens in the server', async () => {
    const fetchStub = sinon.stub().returns(
      Promise.resolve({
        status: 200,
        json: () =>
          Promise.resolve({ success: false, message: 'ErrorFromServer' }),
      }),
    );

    testkit = createPublishCommandTestKit(fetchStub);

    await testkit.given.spec('spec.test1');
    await testkit.when.publish();

    expect(testkit.get.lastError()).to.include(
      'Something Went Wrong, please talk to Fed-Infra\n\n"ErrorFromServer"',
    );
    expect(testkit.get.specsHashes()).to.eqls({});
  });

  it('should return an error if we coulnt call the petri-specs-gateway server', async () => {
    const fetchStub = sinon.stub().throws(new Error('ServerUnabilable'));

    testkit = createPublishCommandTestKit(fetchStub);

    await testkit.given.spec('spec.test1');
    await testkit.when.publish();

    expect(testkit.get.lastError()).to.include(
      "Error reaching the server. Make sure you're connected to Wix network or VPN. ServerUnabilable",
    );
    expect(testkit.get.specsHashes()).to.eqls({});
  });
});
