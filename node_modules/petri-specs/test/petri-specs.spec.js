const path = require('path');
const { expect } = require('chai');
const sh = require('shelljs');
const { convert } = require('..');
const cliTest = require('./cli-test');
const {
  baseFsWith,
  spec,
  translationWithSpecs,
  translationSpec,
} = require('./testkit');
const { without, and } = require('./test-utils');

describe('petri-specs', () => {
  let test;

  beforeEach(
    () => (test = cliTest.create(require.resolve('../bin/petri-specs.js'))),
  );
  afterEach(() => test.teardown());
  after(() => sh.rm('-rf', 'petri-specs') && sh.rm('-rf', 'dist'));

  it('should work for petri specs files', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'petri-specs/MySpecName2.json': JSON.stringify(spec('MySpecName2')),
        }),
      )
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 2 valid specs');
    expect(JSON.parse(test.content('petri-specs/MySpecName.json'))).to.eql(
      spec('MySpecName'),
    );
    expect(JSON.parse(test.content('petri-specs/MySpecName2.json'))).to.eql(
      spec('MySpecName2'),
    );
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName'), spec('MySpecName2')),
    );
  });

  it('should filter invalid specs', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'petri-specs/MySpecName2.json': JSON.stringify(
            spec('MySpecName2', without('scopes')),
          ),
          'petri-specs/MySpecName3.json': JSON.stringify(
            spec('MySpecName3', without('owner')),
          ),
          'petri-specs/MySpecName4.json': JSON.stringify(
            spec('MySpecName4', without('onlyForLoggedInUsers')),
          ),
          'petri-specs/MySpecName5.json': JSON.stringify(
            spec('MySpecName5', without('controlGroup')),
          ),
          'petri-specs/MySpecName6.json': JSON.stringify(
            spec('MySpecName6', without('variants')),
          ),
        }),
      )
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName6" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName')),
    );
  });

  it('should validate scopes', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'petri-specs/MySpecName2.json': JSON.stringify(
            spec('MySpecName2', and({ scopes: ['a', 'a'] })),
          ),
          'petri-specs/MySpecName3.json': JSON.stringify(
            spec('MySpecName3', and({ scopes: [''] })),
          ),
          'petri-specs/MySpecName4.json': JSON.stringify(
            spec('MySpecName4', and({ scopes: [] })),
          ),
          'package.json': '',
        }),
      )
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName')),
    );
  });

  it('should validate groups', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'petri-specs/MySpecName2.json': JSON.stringify(
            spec('MySpecName2', and({ controlGroup: '', variants: ['b'] })),
          ),
          'petri-specs/MySpecName3.json': JSON.stringify(
            spec('MySpecName3', and({ controlGroup: 'a', variants: [] })),
          ),
          'petri-specs/MySpecName4.json': JSON.stringify(
            spec('MySpecName4', and({ controlGroup: 'a', variants: [''] })),
          ),
          'petri-specs/MySpecName5.json': JSON.stringify(
            spec(
              'MySpecName5',
              and({ controlGroup: 'a', variants: ['b', ''] }),
            ),
          ),
          'petri-specs/MySpecName6.json': JSON.stringify(
            spec(
              'MySpecName6',
              and({ controlGroup: 'a', variants: ['b', 'b'] }),
            ),
          ),
          'petri-specs/MySpecName7.json': JSON.stringify(
            spec('MySpecName7', and({ controlGroup: 'a', variants: ['a'] })),
          ),
        }),
      )
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName6" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName7" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName')),
    );
  });

  it('should require n !== 1 legal groups or more', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(
            spec(
              'MySpecName',
              and({ controlGroup: 'a', variants: ['b', 'c'] }),
            ),
          ),
          'petri-specs/MySpecName2.json': JSON.stringify(
            spec('MySpecName2', and({ controlGroup: 'a', variants: ['b'] })),
          ),
          'petri-specs/MySpecName3.json': JSON.stringify(
            spec('MySpecName3', and({ controlGroup: '', variants: [] })),
          ),
          'petri-specs/MySpecName4.json': JSON.stringify(
            spec('MySpecName4', and({ controlGroup: 'a', variants: [] })),
          ),
          'petri-specs/MySpecName5.json': JSON.stringify(
            spec('MySpecName5', and({ controlGroup: 'a', variants: [''] })),
          ),
          'petri-specs/MySpecName6.json': JSON.stringify(
            spec('MySpecName6', and({ controlGroup: '', variants: ['b'] })),
          ),
        }),
      )
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName6" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 3 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign(
        {},
        spec('MySpecName', and({ controlGroup: 'a', variants: ['b', 'c'] })),
        spec('MySpecName2', and({ controlGroup: 'a', variants: ['b'] })),
        spec('MySpecName3', and({ controlGroup: '', variants: [] })),
      ),
    );
  });

  it('should support multiple scopes', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(
            spec('MySpecName', and({ scopes: ['a', 'b', 'c'] })),
          ),
        }),
      )
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName', and({ scopes: ['a', 'b', 'c'] }))),
    );
  });

  it('should do nothing if directory does not exist', () => {
    const response = test.setup(baseFsWith()).execute('build');
    expect(response.code).to.equal(0);
    expect(response.stdout).not.to.contain(
      'create dist/petri-experiments.json',
    );
    expect(response.stdout).not.to.contain('valid specs');
  });

  it('has configurable directory parameter', () => {
    const response = test
      .setup(
        baseFsWith({
          'specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        }),
      )
      .execute('build --directory specs');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName')),
    );
  });

  it('has configurable json parameter', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        }),
      )
      .execute('build --json abc/def.json');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create abc/def.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('abc/def.json'))).to.eql(
      Object.assign({}, spec('MySpecName')),
    );
  });

  it('looks for the directory & json relatively to project top directory', () => {
    const response = test
      .setup(
        baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'abc/placeholder.json': '',
        }),
      )
      .execute('build', {}, { cwd: path.join(test.tmp, 'abc') });

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create ../dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
      Object.assign({}, spec('MySpecName')),
    );
  });

  describe('translation specs', () => {
    it('should work', () => {
      const response = test
        .setup(
          baseFsWith({
            'src/assets/messages_en.json': JSON.stringify(
              translationWithSpecs('translation1', 'translation2'),
            ),
          }),
        )
        .execute('build');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 2 valid specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
        Object.assign(
          {},
          translationSpec('specs.abTranslate.my-scope.translation1'),
          translationSpec('specs.abTranslate.my-scope.translation2'),
        ),
      );
    });

    it('should work for both translation specs and petri specs files', () => {
      const response = test
        .setup(
          baseFsWith({
            'src/assets/messages_en.json': JSON.stringify(
              translationWithSpecs('translation1'),
            ),
            'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          }),
        )
        .execute('build');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 2 valid specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
        Object.assign(
          {},
          translationSpec('specs.abTranslate.my-scope.translation1'),
          spec('MySpecName'),
        ),
      );
    });

    it('should work without a pom file', () => {
      const response = test
        .setup({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'src/assets/messages_en.json': JSON.stringify(
            translationWithSpecs('translation1', 'translation2'),
          ),
          'package.json': '',
        })
        .execute('build');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 1 valid specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(
        Object.assign({}, spec('MySpecName')),
      );
    });
  });

  describe('convert task', () => {
    it('to noop', () => {
      expect(convert()).to.eql({ convertedFilesCount: 0 });
    });
  });
});
