"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const read_pkg_1 = __importDefault(require("read-pkg"));
const cosmiconfig_1 = __importDefault(require("cosmiconfig"));
const lodash_1 = require("lodash");
const jest_validate_1 = require("jest-validate");
const validConfig_1 = __importDefault(require("./validConfig"));
const normalize_1 = __importDefault(require("./normalize"));
const explorer = cosmiconfig_1.default('yoshi', {
    searchPlaces: ['package.json', 'yoshi.config.js'],
});
exports.default = ({ validate = true, cwd = process.cwd() } = {}) => {
    // YOSHI_CONFIG_DIR is a hack for letting different flows to load a fixed config.
    // It is currently being used from both `jest-yoshi-preset`, the flow's cli and
    // cli commands, which are still not handled by the flow and being proxied to legacy flow
    const result = explorer.searchSync(process.env.YOSHI_CONFIG_DIR || cwd);
    const initialConfig = (result ? result.config : {});
    // Load and copy values from a file that extends the config
    if (initialConfig.extends) {
        const extendsConfig = require(initialConfig.extends)
            .defaultConfig;
        lodash_1.defaultsDeep(initialConfig, extendsConfig);
    }
    // Validate correctness
    if (validate) {
        jest_validate_1.validate(initialConfig, {
            exampleConfig: validConfig_1.default,
            recursiveBlacklist: ['resolveAlias'],
        });
    }
    // Load package.json
    const pkgJson = read_pkg_1.default.sync({ cwd });
    // Normalize values
    const config = normalize_1.default(initialConfig, pkgJson);
    return config;
};
//# sourceMappingURL=loadConfig.js.map