"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePublicPath = exports.validateServerEntry = exports.watchDynamicEntries = exports.createServerEntries = exports.overrideRules = exports.addEntry = exports.waitForCompilation = exports.createCompiler = exports.runWebpack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const resolve_1 = __importDefault(require("resolve"));
const webpack_1 = __importDefault(require("webpack"));
const globby_1 = __importDefault(require("globby"));
const formatWebpackMessages_1 = __importDefault(require("react-dev-utils/formatWebpackMessages"));
const watchpack_1 = __importDefault(require("watchpack"));
const queries_1 = require("yoshi-helpers/build/queries");
const utils_1 = require("yoshi-helpers/utils");
const paths_1 = require("yoshi-config/build/paths");
const helpers_1 = require("./utils/helpers");
const suricate_1 = require("./utils/suricate");
const isDevelopment = process.env.NODE_ENV === 'development';
const possibleServerEntries = ['./server', '../dev/server'];
function createCompiler(webpackConfig) {
    let compiler;
    try {
        compiler = webpack_1.default(webpackConfig);
    }
    catch (err) {
        console.log(chalk_1.default.red('Failed to compile.'));
        console.log();
        console.log(err.message || err);
        console.log();
        return process.exit(1);
    }
    return compiler;
}
exports.createCompiler = createCompiler;
function addEntry(entry, hotEntries) {
    let newEntry = {};
    if (typeof entry === 'function') {
        const originalEntry = entry;
        // @ts-ignore
        newEntry = async () => {
            return addEntry(await originalEntry(), hotEntries);
        };
    }
    else if (!Array.isArray(entry) && typeof entry === 'object') {
        const keys = Object.keys(entry);
        for (const entryName of keys) {
            newEntry[entryName] = hotEntries.concat(entry[entryName]);
        }
    }
    else {
        newEntry = hotEntries.concat(entry);
    }
    return newEntry;
}
exports.addEntry = addEntry;
function overrideRules(rules, patch) {
    return rules.map(ruleToPatch => {
        let rule = patch(ruleToPatch);
        if (rule.rules) {
            rule = Object.assign(Object.assign({}, rule), { rules: overrideRules(rule.rules, patch) });
        }
        if (rule.oneOf) {
            rule = Object.assign(Object.assign({}, rule), { oneOf: overrideRules(rule.oneOf, patch) });
        }
        if (rule.use) {
            // @ts-ignore
            rule = Object.assign(Object.assign({}, rule), { use: overrideRules(rule.use, patch) });
        }
        return rule;
    });
}
exports.overrideRules = overrideRules;
function waitForCompilation(compiler) {
    return new Promise((resolve, reject) => {
        compiler.hooks.done.tap('promise', stats => stats.hasErrors() ? reject(stats) : resolve(stats));
    });
}
exports.waitForCompilation = waitForCompilation;
function createServerEntries(context, cwd = process.cwd()) {
    const serverFunctions = fs_extra_1.default.pathExistsSync(path_1.default.join(cwd, paths_1.SRC_DIR))
        ? globby_1.default.sync('**/*.api.(js|ts)', {
            cwd: path_1.default.join(cwd, paths_1.SRC_DIR),
            absolute: true,
        })
        : [];
    const serverRoutes = fs_extra_1.default.pathExistsSync(path_1.default.join(cwd, paths_1.ROUTES_DIR))
        ? globby_1.default.sync('**/*.(js|ts)', {
            cwd: path_1.default.join(cwd, paths_1.ROUTES_DIR),
            absolute: true,
        })
        : [];
    let initServerPath;
    try {
        initServerPath = resolve_1.default.sync(path_1.default.join(cwd, paths_1.SRC_DIR, 'init-server'), {
            extensions: ['.js', '.ts'],
        });
    }
    catch (e) {
        // No 'init-server' file, Do nothing
    }
    // Normalize to an object with short entry names
    const entries = [
        ...serverFunctions,
        ...serverRoutes,
        ...(initServerPath ? [initServerPath] : []),
    ].reduce((acc, filepath) => {
        return Object.assign(Object.assign({}, acc), { [path_1.default.relative(context, filepath).replace(/\.[^/.]+$/, '')]: filepath });
    }, {});
    // Add custom entries for `yoshi-server`
    entries['routes/_api_'] = 'yoshi-server/build/routes/api';
    if (isDevelopment) {
        entries['routes/_launchEditor_'] = 'yoshi-server/build/routes/launchEditor';
    }
    return entries;
}
exports.createServerEntries = createServerEntries;
function watchDynamicEntries(watching, cwd = process.cwd()) {
    const wp = new watchpack_1.default({});
    wp.on('aggregated', () => {
        watching.invalidate();
    });
    wp.watch([], [path_1.default.join(cwd, paths_1.SRC_DIR), path_1.default.join(cwd, paths_1.ROUTES_DIR)]);
}
exports.watchDynamicEntries = watchDynamicEntries;
function validateServerEntry({ cwd = process.cwd(), extensions, yoshiServer = false, }) {
    const serverEntry = possibleServerEntries.find(entry => {
        return (globby_1.default.sync(`${entry}(${extensions.join('|')})`, {
            cwd: path_1.default.join(cwd, paths_1.SRC_DIR),
        }).length > 0);
    });
    if (!serverEntry && !yoshiServer) {
        throw new Error(`We couldn't find your server entry. Please use one of the defaults:
      - "src/server": for a fullstack project
      - "dev/server": for a client only project`);
    }
    return serverEntry;
}
exports.validateServerEntry = validateServerEntry;
function calculatePublicPath({ suricate, appName, devServerUrl, useUnversionedBaseUrl, }) {
    if (process.env.YOSHI_PUBLIC_PATH) {
        return process.env.YOSHI_PUBLIC_PATH;
    }
    // default public path
    let publicPath = '/';
    if (!queries_1.inTeamCity() || isDevelopment) {
        // When on local machine or on dev environment,
        if (suricate) {
            publicPath = suricate_1.getDevServerUrl(appName);
        }
        else {
            // set the local dev-server url as the public path
            publicPath = devServerUrl;
        }
    }
    // In case we are running in CI and there is a pom.xml file, change the public path according to the path on the cdn
    // The path is created using artifactName from pom.xml and artifact version from an environment param.
    if (queries_1.shouldDeployToCDN()) {
        publicPath = utils_1.getProjectCDNBasePath(useUnversionedBaseUrl);
    }
    return publicPath;
}
exports.calculatePublicPath = calculatePublicPath;
async function runWebpack(configs) {
    try {
        const compiler = createCompiler(configs.filter(helpers_1.isTruthy));
        const webpackStats = await new Promise((resolve, reject) => {
            // @ts-ignore
            compiler.run((err, stats) => (err ? reject(err) : resolve(stats)));
        });
        // @ts-ignore
        const messages = formatWebpackMessages_1.default(webpackStats.toJson({}, true));
        if (messages.errors.length) {
            // Error handled by webpack
            console.log(chalk_1.default.red('Failed to compile.\n'));
            console.error(messages.errors.join('\n\n'));
            process.exit(1);
        }
        if (messages.warnings.length) {
            console.log(chalk_1.default.yellow('Compiled with warnings.\n'));
            console.log(messages.warnings.join('\n\n'));
        }
        else {
            console.log(chalk_1.default.green('Compiled successfully.\n'));
        }
        return webpackStats;
    }
    catch (error) {
        // Error webpack couldn't handle
        console.log(chalk_1.default.red('Failed to compile.\n'));
        console.error(error);
        process.exit(1);
    }
}
exports.runWebpack = runWebpack;
//# sourceMappingURL=webpack-utils.js.map