"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerProcessWithHMR = exports.ServerProcess = void 0;
const path_1 = __importDefault(require("path"));
const stream_1 = __importDefault(require("stream"));
const chalk_1 = __importDefault(require("chalk"));
const wait_port_1 = __importDefault(require("wait-port"));
const execa_1 = __importDefault(require("execa"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const bootstrap_utils_1 = require("yoshi-helpers/build/bootstrap-utils");
const utils_1 = require("yoshi-helpers/build/utils");
const paths_1 = require("yoshi-config/build/paths");
const socket_server_1 = __importDefault(require("./socket-server"));
const suricate_1 = require("./utils/suricate");
function serverLogPrefixer(appName) {
    const prefix = appName ? `[${utils_1.stripOrganization(appName)}]` : `[SERVER]`;
    return new stream_1.default.Transform({
        transform(chunk, encoding, callback) {
            this.push(`${chalk_1.default.greenBright(prefix)}: ${chunk.toString()}`);
            callback();
        },
    });
}
function notUndefined(x) {
    return x !== undefined;
}
class ServerProcess {
    constructor({ cwd = process.cwd(), serverFilePath, env, port, useAppName, appName, inspectArg, }) {
        this.cwd = cwd;
        this.serverFilePath = serverFilePath;
        this.env = env;
        this.port = port;
        this.useAppName = useAppName;
        this.appName = appName;
        this.inspectArg = inspectArg;
    }
    async initialize() {
        const serverLogFile = path_1.default.join(this.cwd, paths_1.SERVER_LOG_FILE);
        // Verify that the `target/server.log` file exist before we write to it
        fs_extra_1.default.ensureFileSync(serverLogFile);
        const bootstrapEnvironmentParams = bootstrap_utils_1.getDevelopmentEnvVars({
            port: this.port,
            cwd: this.cwd,
        });
        const userServerFilePath = path_1.default.isAbsolute(this.serverFilePath)
            ? this.serverFilePath
            : path_1.default.join(process.cwd(), this.serverFilePath);
        const serverProcessWorker = require.resolve('./server-process-worker-with-transpilation.js');
        this.child = execa_1.default.node(serverProcessWorker, [], {
            stdio: 'pipe',
            // execArgv
            nodeOptions: [this.inspectArg]
                .filter(notUndefined)
                .map(arg => arg.replace('debug', 'inspect')),
            env: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, process.env), { PORT: `${this.port}` }), bootstrapEnvironmentParams), this.env), { __SERVER_FILE_PATH__: userServerFilePath }),
        });
        const serverLogWriteStream = fs_extra_1.default.createWriteStream(path_1.default.join(this.cwd, paths_1.SERVER_LOG_FILE));
        const serverOutLogStream = this.child.stdout.pipe(serverLogPrefixer(this.useAppName ? this.appName : undefined));
        serverOutLogStream.pipe(serverLogWriteStream);
        serverOutLogStream.pipe(process.stdout);
        const serverErrorLogStream = this.child.stderr.pipe(serverLogPrefixer(this.useAppName ? this.appName : undefined));
        serverErrorLogStream.pipe(serverLogWriteStream);
        serverErrorLogStream.pipe(process.stderr);
        await wait_port_1.default({
            port: this.port,
            output: 'silent',
            timeout: 20000,
        });
    }
    async close() {
        // @ts-ignore
        if (this.child && this.child.exitCode === null) {
            this.child.kill();
            await new Promise(resolve => {
                const check = () => {
                    if (this.child && this.child.killed) {
                        return resolve();
                    }
                    setTimeout(check, 100);
                };
                setTimeout(check, 100);
            });
        }
    }
    async restart() {
        await this.close();
        await this.initialize();
    }
}
exports.ServerProcess = ServerProcess;
class ServerProcessWithHMR extends ServerProcess {
    constructor({ cwd, serverFilePath, socketServer, suricate, appName, port, inspectArg, }) {
        super({
            cwd,
            port,
            serverFilePath,
            appName,
            env: {
                HMR_PORT: `${socketServer.hmrPort}`,
                NODE_ENV: 'development',
            },
            inspectArg,
        });
        this.socketServer = socketServer;
        this.suricate = suricate;
    }
    async initialize() {
        if (this.suricate) {
            suricate_1.createSocket(this.appName, this.port);
        }
        await this.socketServer.initialize();
        this.socketServer.on('message', this.onMessage.bind(this));
        await super.initialize();
    }
    onMessage(response) {
        this.resolve && this.resolve(response);
    }
    send(message) {
        this.socketServer.send(message);
        return new Promise(resolve => {
            this.resolve = resolve;
        });
    }
    static async create({ cwd = process.cwd(), serverFilePath, appName, suricate, port, inspectArg, }) {
        const socketServer = await socket_server_1.default.create();
        return new ServerProcessWithHMR({
            socketServer,
            cwd,
            serverFilePath,
            appName,
            suricate,
            port,
            inspectArg,
        });
    }
}
exports.ServerProcessWithHMR = ServerProcessWithHMR;
//# sourceMappingURL=server-process.js.map