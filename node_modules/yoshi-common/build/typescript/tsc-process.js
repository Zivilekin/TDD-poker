"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeError = void 0;
const child_process_1 = require("child_process");
const events_1 = require("events");
const execa = require("execa");
const paths_1 = require("yoshi-config/build/paths");
const formatter_1 = require("./formatter");
const copy_files_1 = __importDefault(require("./copy-files"));
const tsconfig_enforcer_1 = require("./tsconfig-enforcer");
const changeDetectedRegex = /File change detected/;
const foundErrorsRegex = /Found [1-9]+/;
const zeroErrorsRegex = /Found 0+/;
const typescriptErrorRegex = /error TS\d+:/;
const isRecompiling = (lines) => lines.some(line => changeDetectedRegex.test(line));
const isCompileWithErrors = (lines) => lines.some(line => foundErrorsRegex.test(line));
const isCompileSuccessfully = (lines) => lines.some(line => zeroErrorsRegex.test(line));
const isErrorMessage = (lines) => lines.some(line => typescriptErrorRegex.test(line));
class TypeError extends Error {
    constructor(errors) {
        super(errors.join('\n\n'));
        this.errors = errors;
    }
}
exports.TypeError = TypeError;
class TscProcess extends events_1.EventEmitter {
    constructor({ copyFiles = true, cwd = process.cwd(), }) {
        super();
        this.copyFiles = copyFiles;
        this.cwd = cwd;
    }
    build() {
        tsconfig_enforcer_1.enforceTsconfig({
            cwd: this.cwd,
        });
        if (this.copyFiles) {
            copy_files_1.default({
                watch: false,
                outDir: paths_1.ES_DIR,
                rootDir: paths_1.SRC_DIR,
                cwd: this.cwd,
            });
        }
        const tscBin = require.resolve('typescript/bin/tsc');
        return new Promise((resolve, reject) => {
            return execa('node', [tscBin])
                .then(resolve)
                .catch(({ stdout }) => {
                const lines = stdout.split('\n');
                const errors = lines
                    .filter((line) => typescriptErrorRegex.test(line))
                    .map((error) => formatter_1.formatTypescriptError(error));
                reject(new TypeError(errors));
            });
        });
    }
    watch() {
        tsconfig_enforcer_1.enforceTsconfig({
            cwd: this.cwd,
        });
        if (this.copyFiles) {
            copy_files_1.default({
                watch: true,
                outDir: paths_1.ES_DIR,
                rootDir: paths_1.SRC_DIR,
                cwd: this.cwd,
            });
        }
        const tscBin = require.resolve('typescript/bin/tsc');
        const tscWorker = child_process_1.spawn('node', [tscBin, '--watch', '--pretty', 'false']);
        process.on('exit', () => tscWorker.kill('SIGTERM'));
        let errors = [];
        // Emit the first compiling message to give fast feedback to the user
        this.emit('message', { type: 'compiling' });
        tscWorker.stdout.on('data', buffer => {
            const lines = buffer.toString().split('\n');
            if (isErrorMessage(lines)) {
                // accumulate errors
                errors = errors.concat(lines.filter((line) => typescriptErrorRegex.test(line)));
            }
            if (isRecompiling(lines)) {
                this.emit('message', { type: 'compiling' });
            }
            if (isCompileWithErrors(lines)) {
                this.emit('message', { type: 'compile-with-errors', errors });
                // after errors were sent, remove current errors from memory
                errors = [];
            }
            if (isCompileSuccessfully(lines)) {
                this.emit('message', { type: 'compile-successfully' });
            }
        });
        tscWorker.on('exit', code => {
            throw new Error(`tsc exited with code ${code}`);
        });
    }
}
exports.default = TscProcess;
//# sourceMappingURL=tsc-process.js.map