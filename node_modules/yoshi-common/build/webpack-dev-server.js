"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackDevServer = exports.host = exports.redirectMiddleware = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const path_1 = __importDefault(require("path"));
const cors_1 = __importDefault(require("cors"));
const webpack_dev_server_1 = __importDefault(require("webpack-dev-server"));
const paths_1 = require("yoshi-config/build/paths");
const suricate_1 = require("./utils/suricate");
function redirectMiddleware(hostname, port) {
    return (req, res, next) => {
        if (!/\.min\.(js|css)/.test(req.originalUrl)) {
            return next();
        }
        const httpModule = req.protocol === 'http' ? http_1.default : https_1.default;
        const options = {
            port,
            hostname,
            path: req.originalUrl.replace('.min', ''),
            rejectUnauthorized: false,
        };
        const request = httpModule.request(options, proxiedResponse => {
            for (const header in proxiedResponse.headers) {
                // @ts-ignore
                res.setHeader(header, proxiedResponse.headers[header]);
            }
            proxiedResponse.pipe(res);
        });
        request.on('error', () => next()).end();
    };
}
exports.redirectMiddleware = redirectMiddleware;
// The server should be accessible externally
exports.host = '0.0.0.0';
class WebpackDevServer extends webpack_dev_server_1.default {
    constructor(compiler, { publicPath, https, port, suricate, appName, cwd = process.cwd(), }) {
        if (suricate) {
            compiler.hooks.done.tapPromise('webpack-dev-server/suricate', async () => {
                this.suricateApi.updateCache();
            });
        }
        super(compiler, {
            // Enable gzip compression for everything served
            compress: true,
            clientLogLevel: 'error',
            contentBase: path_1.default.join(cwd, paths_1.STATICS_DIR),
            hot: true,
            publicPath,
            writeToDisk: true,
            // We write our own errors/warnings to the console
            quiet: true,
            noInfo: true,
            https,
            host: exports.host,
            overlay: true,
            // https://github.com/wix/yoshi/pull/1191
            allowedHosts: [
                '.wix.com',
                '.editorx.com',
                '.editorx.io',
                '.wixsite.com',
                '.ooidev.com',
                '.editor-flow-dev.com',
                '.deviantart.lan',
            ],
            // TODO - check if needed for suricate and how can be better implemented
            disableHostCheck: suricate,
            before(expressApp) {
                // Send cross origin headers
                expressApp.use(cors_1.default(
                // TODO - check if needed for suricate and how can be better implemented
                suricate
                    ? {
                        origin: (requestOrigin, cb) => cb(null, true),
                        credentials: true,
                    }
                    : {}));
                // Redirect `.min.(js|css)` to `.(js|css)`
                expressApp.use(redirectMiddleware(exports.host, port));
            },
        });
        this.port = port;
        this.https = https;
        this.compiler = compiler;
        this.appName = appName;
        this.suricate = suricate;
    }
    // Update sockets with new stats, we use the sockWrite() method
    // to update the hot client with server data
    send(type, data) {
        // @ts-ignore
        return this.sockWrite(this.sockets, type, data);
    }
    listenPromise() {
        const listenTarget = this.suricate
            ? suricate_1.createDevServerSocket(this.appName, this.port, {
                cache: process.env.ENABLE_SURICATE_CACHE === 'true',
            })
            : this.port;
        if (this.suricate) {
            this.suricateApi = listenTarget;
        }
        return new Promise((resolve, reject) => {
            super.listen(listenTarget, exports.host, err => (err ? reject(err) : resolve()));
        });
    }
}
exports.WebpackDevServer = WebpackDevServer;
//# sourceMappingURL=webpack-dev-server.js.map