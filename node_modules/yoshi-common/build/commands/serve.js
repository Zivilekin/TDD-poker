"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveApp = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const loadConfig_1 = __importDefault(require("yoshi-config/loadConfig"));
const server_start_file_1 = require("yoshi-helpers/build/server-start-file");
const server_start_file_parser_1 = require("yoshi-helpers/build/server-start-file-parser");
const paths_1 = require("yoshi-config/build/paths");
const server_process_1 = require("../server-process");
const cdn_1 = require("../cdn");
exports.default = async ({ cwd = process.cwd(), env } = {}) => {
    process.env.NODE_ENV = 'production';
    process.env.BABEL_ENV = 'production';
    const config = loadConfig_1.default({ cwd });
    if (config.experimentalMonorepo) {
        throw new Error('use yoshi-flow-monorepo/serve instead');
    }
    return exports.serveApp({ config, cwd, env });
};
exports.serveApp = async ({ config, cwd, env = {}, useAppName, }) => {
    var _a;
    const serverFilePath = (_a = server_start_file_parser_1.serverStartFileParser(config.pkgJson)) !== null && _a !== void 0 ? _a : server_start_file_1.getServerStartFile({ cwd });
    const staticsDir = path_1.default.join(cwd, paths_1.STATICS_DIR);
    if (!fs_1.default.existsSync(staticsDir) || fs_1.default.readdirSync(staticsDir).length === 0) {
        throw new Error(`Error: ${staticsDir} directory is empty. Run the build before running serve`);
    }
    const serverProcess = new server_process_1.ServerProcess({
        serverFilePath,
        appName: config.name,
        port: config.servers.app.port,
        useAppName,
        env: Object.assign({ NODE_ENV: 'development' }, env),
    });
    const [, cdn] = await Promise.all([
        serverProcess.initialize(),
        cdn_1.startCDN({
            ssl: config.servers.cdn.ssl,
            port: config.servers.cdn.port,
            cwd,
        }),
    ]);
    const closeServers = () => Promise.all([serverProcess.close(), cdn.close()]);
    return closeServers;
};
//# sourceMappingURL=serve.js.map