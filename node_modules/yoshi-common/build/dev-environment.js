"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const chokidar_1 = __importDefault(require("chokidar"));
const unistore_1 = __importDefault(require("unistore"));
const execa_1 = __importDefault(require("execa"));
const formatWebpackMessages_1 = __importDefault(require("react-dev-utils/formatWebpackMessages"));
const WebpackDevServerUtils_1 = require("react-dev-utils/WebpackDevServerUtils");
const debounce_1 = __importDefault(require("lodash/debounce"));
const paths_1 = require("yoshi-config/build/paths");
const open_browser_1 = __importDefault(require("./open-browser"));
const server_process_1 = require("./server-process");
const webpack_dev_server_1 = require("./webpack-dev-server");
const webpack_utils_1 = require("./webpack-utils");
const helpers_1 = require("./utils/helpers");
const suricate_1 = require("./utils/suricate");
const dev_environment_logger_1 = __importDefault(require("./dev-environment-logger"));
const formatter_1 = require("./typescript/formatter");
const tsc_process_1 = __importDefault(require("./typescript/tsc-process"));
const run_babel_1 = __importDefault(require("./typescript/run-babel"));
class DevEnvironment {
    constructor(props) {
        this.onStoryBookMessage = (message) => {
            switch (message.type) {
                case 'error':
                    this.store.setState({
                        Storybook: { status: 'errors', errors: [message.error] },
                    });
                    break;
                case 'compiling':
                    this.store.setState({
                        Storybook: { status: 'compiling', errors: [], warnings: [] },
                    });
                    break;
                case 'listening':
                    open_browser_1.default(`http://localhost:${message.port}`);
                    break;
                case 'finished-log':
                    // @ts-ignore
                    const messages = formatWebpackMessages_1.default(message.stats);
                    const isSuccessful = !messages.errors.length && !messages.warnings.length;
                    if (isSuccessful) {
                        const urls = WebpackDevServerUtils_1.prepareUrls('http', webpack_dev_server_1.host, Number(message.port));
                        this.store.setState({
                            Storybook: Object.assign({ status: 'success', urls }, messages),
                        });
                    }
                    else if (messages.errors.length) {
                        if (messages.errors.length > 1) {
                            messages.errors.length = 1;
                        }
                        this.store.setState({
                            Storybook: Object.assign({ status: 'errors' }, messages),
                        });
                    }
                    else if (messages.warnings.length) {
                        this.store.setState({
                            Storybook: Object.assign({ status: 'warnings' }, messages),
                        });
                    }
                    break;
            }
        };
        this.onTscMessage = (message) => {
            switch (message.type) {
                // in case there is an error with tsc
                case 'error':
                    throw new Error(message.error);
                case 'compiling':
                    this.store.setState({
                        TypeScript: { status: 'compiling' },
                    });
                    break;
                case 'compile-successfully':
                    this.store.setState({
                        TypeScript: { status: 'success' },
                    });
                    break;
                case 'compile-with-errors':
                    this.store.setState({
                        TypeScript: {
                            status: 'errors',
                            errors: message.errors.map(error => formatter_1.formatTypescriptError(error)),
                        },
                    });
                    break;
            }
        };
        this.props = props;
        this.store = unistore_1.default();
        const { multiCompiler, webpackDevServer, storybookProcess, tscProcess, } = props;
        if (multiCompiler && webpackDevServer) {
            multiCompiler.hooks.invalid.tap('recompile-log', () => {
                this.store.setState({
                    DevServer: {
                        status: 'compiling',
                    },
                });
            });
            multiCompiler.hooks.done.tap('finished-log', stats => {
                // @ts-ignore
                const messages = formatWebpackMessages_1.default(stats.toJson({}, true));
                const isSuccessful = !messages.errors.length && !messages.warnings.length;
                if (isSuccessful) {
                    const devServerUrls = WebpackDevServerUtils_1.prepareUrls(webpackDevServer.https ? 'https' : 'http', webpack_dev_server_1.host, webpackDevServer.port);
                    this.store.setState({
                        DevServer: Object.assign({ status: 'success', urls: devServerUrls }, messages),
                    });
                }
                else if (messages.errors.length) {
                    if (messages.errors.length > 1) {
                        messages.errors.length = 1;
                    }
                    this.store.setState({
                        DevServer: Object.assign({ status: 'errors' }, messages),
                    });
                }
                else if (messages.warnings.length) {
                    this.store.setState({
                        DevServer: Object.assign({ status: 'warnings' }, messages),
                    });
                }
            });
        }
        if (storybookProcess) {
            storybookProcess.on('message', this.onStoryBookMessage);
        }
        if (tscProcess) {
            tscProcess.on('message', this.onTscMessage);
        }
    }
    async triggerBrowserRefresh(jsonStats) {
        const { webpackDevServer } = this.props;
        if (webpackDevServer) {
            await webpackDevServer.send('hash', jsonStats.hash);
            await webpackDevServer.send('ok', {});
        }
    }
    async showErrorsOnBrowser(jsonStats) {
        const { webpackDevServer } = this.props;
        if (webpackDevServer) {
            if (jsonStats.errors.length > 0) {
                await webpackDevServer.send('errors', jsonStats.errors);
            }
            else if (jsonStats.warnings.length > 0) {
                await webpackDevServer.send('warnings', jsonStats.warnings);
            }
        }
    }
    static getSslCertificate(https) {
        const customCertPath = process.env.CUSTOM_CERT_PATH;
        const customCertKeyPath = process.env.CUSTOM_CERT_KEY_PATH;
        if (customCertPath && customCertKeyPath) {
            return {
                cert: customCertPath,
                key: customCertKeyPath,
            };
        }
        return https;
    }
    startWebWorkerHotUpdate(compiler) {
        compiler.watch({}, async (error, stats) => {
            // We save the result of this build to webpack-dev-server's internal state so the last
            // server build results are sent to the browser on every refresh
            //
            // https://github.com/webpack/webpack-dev-server/blob/master/lib/Server.js#L144
            // @ts-ignore
            this._stats = stats;
            const jsonStats = stats.toJson();
            if (!error && !stats.hasErrors()) {
                await this.triggerBrowserRefresh(jsonStats);
            }
            else {
                await this.showErrorsOnBrowser(jsonStats);
            }
        });
    }
    startServerHotUpdate(compiler) {
        const { serverProcess } = this.props;
        const watcher = compiler.watch({}, async (error, stats) => {
            // We save the result of this build to webpack-dev-server's internal state so the last
            // server build results are sent to the browser on every refresh
            //
            // https://github.com/webpack/webpack-dev-server/blob/master/lib/Server.js#L144
            // @ts-ignore
            this._stats = stats;
            const jsonStats = stats.toJson();
            // If the spawned server process has died, restart it
            if ((serverProcess === null || serverProcess === void 0 ? void 0 : serverProcess.child) &&
                // @ts-ignore
                serverProcess.child.exitCode !== null) {
                await serverProcess.restart();
                await this.triggerBrowserRefresh(jsonStats);
            }
            // If it's alive, send it a message to trigger HMR
            else {
                // If there are no errors and the server can be refreshed
                // then send it a signal and wait for a responsne
                if ((serverProcess === null || serverProcess === void 0 ? void 0 : serverProcess.child) && !error && !stats.hasErrors()) {
                    const { success } = (await serverProcess.send({}));
                    // HMR wasn't successful, restart the server process
                    if (!success) {
                        await serverProcess.restart();
                    }
                    await this.triggerBrowserRefresh(jsonStats);
                }
                else {
                    await this.showErrorsOnBrowser(jsonStats);
                }
            }
        });
        if (this.props.yoshiServer) {
            const apiFilesGlobPattern = ['routes/**/*.(js|ts)', '**/*.api.(js|ts)'];
            const absoluteRootDir = path_1.default.join(this.props.cwd, paths_1.SRC_DIR);
            const apiWatcher = chokidar_1.default.watch(apiFilesGlobPattern, {
                cwd: absoluteRootDir,
                ignoreInitial: true,
            });
            apiWatcher.on('add', () => {
                watcher.invalidate();
            });
        }
    }
    async start() {
        const { multiCompiler, webpackDevServer, serverProcess, suricate, appName, startUrl, tscProcess, cwd, } = this.props;
        if (tscProcess) {
            tscProcess.watch();
            run_babel_1.default({
                watch: true,
                cwd,
            });
        }
        if (multiCompiler && webpackDevServer) {
            const compilationPromise = new Promise(resolve => {
                multiCompiler.hooks.done.tap('done', resolve);
            });
            // Start Webpack compilation
            await webpackDevServer.listenPromise();
            await compilationPromise;
        }
        // start app server if exists
        if (serverProcess) {
            await serverProcess.initialize();
            const serverUrls = WebpackDevServerUtils_1.prepareUrls('http', webpack_dev_server_1.host, serverProcess.port);
            this.store.setState({
                AppServer: {
                    status: 'success',
                    urls: serverUrls,
                },
            });
            const actualStartUrl = suricate
                ? suricate_1.getUrl(appName)
                : startUrl || 'http://localhost:3000';
            open_browser_1.default(actualStartUrl);
        }
    }
    static async create({ webpackConfigs, serverFilePath, https, webpackDevServerPort, appServerPort, enableClientHotUpdates, cwd = process.cwd(), createEjsTemplates = false, appName, startUrl, suricate = false, storybook = false, compileTypeScriptFiles = false, yoshiServer = false, inspectArg, }) {
        const [clientConfig, serverConfig] = webpackConfigs;
        let serverProcess;
        if (serverFilePath) {
            serverProcess = await server_process_1.ServerProcessWithHMR.create({
                serverFilePath,
                cwd,
                port: appServerPort,
                suricate,
                appName,
                inspectArg,
            });
            if (serverProcess && serverConfig) {
                if (!serverConfig.entry) {
                    throw new Error('server webpack config was created without an entry');
                }
                // Add server hot entry
                if (!suricate) {
                    serverConfig.entry = webpack_utils_1.addEntry(serverConfig.entry, [
                        `${require.resolve('./utils/server-hot-client')}?${serverProcess.socketServer.hmrPort}`,
                    ]);
                }
            }
        }
        let publicPath;
        if (clientConfig) {
            publicPath = clientConfig.output.publicPath;
            // Add client hot entries
            if (enableClientHotUpdates) {
                if (!clientConfig.entry) {
                    throw new Error('client webpack config was created without an entry');
                }
                const hmrSocketPath = suricate
                    ? suricate_1.getDevServerSocketPath(appName)
                    : publicPath;
                const hotEntries = [
                    require.resolve('webpack/hot/dev-server'),
                    // Adding the query param with the CDN URL allows HMR when working with a production site
                    // because the bundle is requested from "parastorage" we need to specify to open the socket to localhost
                    `${require.resolve('webpack-dev-server/client')}?${hmrSocketPath}`,
                ];
                // Add hot entries as a separate entry if using experimental build html
                if (createEjsTemplates) {
                    clientConfig.entry = Object.assign(Object.assign({}, clientConfig.entry), { hot: hotEntries });
                }
                else {
                    clientConfig.entry = webpack_utils_1.addEntry(clientConfig.entry, hotEntries);
                }
            }
        }
        let multiCompiler;
        let clientCompiler;
        let serverCompiler;
        let webWorkerCompiler;
        let webWorkerServerCompiler;
        if (webpackConfigs.length > 0) {
            multiCompiler = webpack_utils_1.createCompiler(webpackConfigs.filter(helpers_1.isTruthy));
            clientCompiler = multiCompiler.compilers[0];
            serverCompiler = multiCompiler.compilers[1];
            webWorkerCompiler = multiCompiler.compilers[2];
            webWorkerServerCompiler = multiCompiler.compilers[3];
        }
        let webpackDevServer;
        if (clientCompiler) {
            webpackDevServer = new webpack_dev_server_1.WebpackDevServer(clientCompiler, {
                publicPath: publicPath,
                https: DevEnvironment.getSslCertificate(https),
                port: webpackDevServerPort,
                appName,
                suricate,
                cwd,
            });
        }
        let storybookProcess;
        if (storybook) {
            const pathToStorybookWorker = path_1.default.join(__dirname, 'storybook', 'storybook-worker');
            // TODO: This line starts storybook
            // This should be refactored and be moved to start method
            storybookProcess = execa_1.default.node(pathToStorybookWorker);
        }
        let tscProcess;
        if (compileTypeScriptFiles) {
            tscProcess = new tsc_process_1.default({ cwd });
        }
        const devEnvironment = new DevEnvironment({
            webpackDevServer,
            serverProcess,
            multiCompiler,
            appName,
            suricate,
            startUrl,
            tscProcess,
            storybookProcess,
            cwd,
            yoshiServer,
        });
        if (serverCompiler) {
            devEnvironment.startServerHotUpdate(serverCompiler);
        }
        if (webWorkerCompiler) {
            devEnvironment.startWebWorkerHotUpdate(webWorkerCompiler);
        }
        if (webWorkerServerCompiler) {
            devEnvironment.startWebWorkerHotUpdate(webWorkerServerCompiler);
        }
        devEnvironment.store.subscribe(debounce_1.default((state) => dev_environment_logger_1.default({ state, appName, suricate }), 300));
        return devEnvironment;
    }
}
exports.default = DevEnvironment;
//# sourceMappingURL=dev-environment.js.map