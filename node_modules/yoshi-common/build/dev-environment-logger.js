"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const clearConsole_1 = __importDefault(require("react-dev-utils/clearConsole"));
const suricate_1 = require("./utils/suricate");
const isInteractive = process.stdout.isTTY;
const logSuricateUrls = (type, appName) => {
    switch (type) {
        case 'AppServer':
            console.log(`  ${chalk_1.default.bold('Public:')} ${chalk_1.default.magenta(suricate_1.getUrl(appName))}`);
            break;
        case 'DevServer':
            console.log(`  ${chalk_1.default.bold('Public:')} ${chalk_1.default.magenta(suricate_1.getDevServerUrl(appName))}`);
            break;
    }
};
const logMessageByProcessType = {
    AppServer: `Your server is starting and should be accessible from your browser.`,
    Storybook: 'Storybook is starting and should be accessible from your browser.',
    DevServer: `Your bundles and other static assets are served from your ${chalk_1.default.bold('dev-server')}.`,
    TypeScript: 'TypeScript compiled successfully',
};
const logUrls = ({ processType, urls, suricate, appName, }) => {
    console.log();
    console.log(logMessageByProcessType[processType]);
    console.log();
    if (suricate && processType !== 'Storybook') {
        logSuricateUrls(processType, appName);
    }
    else {
        console.log(`  ${chalk_1.default.bold('Local:')}            ${urls === null || urls === void 0 ? void 0 : urls.localUrlForTerminal}`);
        console.log(`  ${chalk_1.default.bold('On Your Network:')}  ${urls === null || urls === void 0 ? void 0 : urls.lanUrlForTerminal}`);
    }
    console.log();
};
const getProcessName = (type) => chalk_1.default.greenBright(`[${type.toUpperCase()}]`);
const logProcessState = ({ processType, suricate, appName, }, state) => {
    switch (state.status) {
        case 'compiling':
            console.log();
            console.log(`${getProcessName(processType)}:`, 'Compiling...');
            break;
        case 'success':
            if (processType === 'TypeScript') {
                console.log('');
                console.log('Found 0 type errors. Watching for file changes.');
            }
            else {
                logUrls({ processType, suricate, appName, urls: state.urls });
            }
            break;
    }
};
const hasErrorsOrWarnings = (state) => {
    return Object.values(state).some(processState => ['errors', 'warnings'].includes(processState === null || processState === void 0 ? void 0 : processState.status));
};
const logStateErrorsOrWarnings = (state) => {
    var _a, _b, _c, _d, _e;
    const { DevServer, TypeScript, Storybook } = state;
    if (TypeScript && TypeScript.status === 'errors') {
        console.log((_a = TypeScript.errors) === null || _a === void 0 ? void 0 : _a.join('\n\n'));
        return;
    }
    if (DevServer && DevServer.status === 'errors') {
        console.log(chalk_1.default.red('Failed to compile.\n'));
        console.log((_b = DevServer.errors) === null || _b === void 0 ? void 0 : _b.join('\n\n'));
        return;
    }
    if (Storybook && Storybook.status === 'errors') {
        console.log(chalk_1.default.red('Failed to compile.\n'));
        console.log((_c = Storybook.errors) === null || _c === void 0 ? void 0 : _c.join('\n\n'));
        return;
    }
    if (DevServer && DevServer.status === 'warnings') {
        console.log(chalk_1.default.red('Compiled with warnings.\n'));
        console.log((_d = DevServer.warnings) === null || _d === void 0 ? void 0 : _d.join('\n\n'));
        return;
    }
    if (Storybook && Storybook.status === 'warnings') {
        console.log(chalk_1.default.red('Compiled with warnings.\n'));
        console.log((_e = Storybook.warnings) === null || _e === void 0 ? void 0 : _e.join('\n\n'));
        return;
    }
};
const isAllCompiled = (state) => {
    return Object.keys(state).every(stateName => {
        const processState = state[stateName];
        return (processState === null || processState === void 0 ? void 0 : processState.status) === 'success';
    });
};
exports.default = ({ state, appName, suricate, }) => {
    if (isInteractive && !process.env.DEBUG) {
        clearConsole_1.default();
    }
    if (hasErrorsOrWarnings(state)) {
        return logStateErrorsOrWarnings(state);
    }
    if (isAllCompiled(state)) {
        console.log(chalk_1.default.green('Compiled successfully!'));
    }
    else {
        console.log(chalk_1.default.bold('Compiling...'));
    }
    for (const processTypeKey in state) {
        const processType = processTypeKey;
        const processState = state[processType];
        processState &&
            logProcessState({ processType, suricate, appName }, processState);
    }
    console.log();
    console.log('Note that the development build is not optimized.');
    console.log(`To create a production build, use ${chalk_1.default.cyan('npm run build')}.`);
    console.log();
};
//# sourceMappingURL=dev-environment-logger.js.map