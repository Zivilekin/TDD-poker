"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_sources_1 = require("webpack-sources");
const fs = require("fs");
const path = require("path");
const postcss = require("postcss");
const extractStyles = require("postcss-extract-styles");
const postcssPlugin_1 = require("./postcssPlugin");
const prefixer = require("postcss-prefix-selector");
const crypto_1 = require("crypto");
const webpack = require("webpack");
class TPAStylePlugin {
    constructor(options) {
        this._options = Object.assign({ pattern: [/"\w+\([^"]*\)"/, /START|END|DIR|STARTSIGN|ENDSIGN|DEG\-START|DEG\-END/] }, options);
        const hash = crypto_1.createHash('md5')
            .update(new Date().getTime().toString())
            .digest('hex');
        this.compilationHash = `__${hash.substr(0, 6)}__`;
    }
    apply(compiler) {
        const shouldEscapeContent = ['cheap-module-eval-source-map', 'cheap-eval-source-map'].includes(compiler.options.devtool);
        this.replaceRuntimeModule(compiler);
        compiler.hooks.compilation.tap(TPAStylePlugin.pluginName, compilation => {
            compilation.hooks.optimizeChunkAssets.tapAsync(TPAStylePlugin.pluginName, (chunks, callback) => {
                this.extract(compilation, chunks)
                    .then(extractResults => this.replaceSource(compilation, extractResults, shouldEscapeContent))
                    .then(() => callback())
                    .catch(callback);
            });
        });
    }
    replaceRuntimeModule(compiler) {
        const runtimePath = path.resolve(__dirname, '../../runtime.js');
        const nmrp = new webpack.NormalModuleReplacementPlugin(/runtime\.js$/, resource => {
            if (fs.realpathSync(resource.resource) !== runtimePath) {
                return;
            }
            const dirname = path.dirname(resource.resource);
            resource.request = './dist/runtime/main.js';
            resource.resource = path.join(dirname, 'dist/runtime/main.js');
            resource.loaders.push({
                loader: path.join(__dirname, 'runtimeLoader.js'),
                options: JSON.stringify({ compilationHash: this.compilationHash }),
            });
        });
        nmrp.apply(compiler);
    }
    extract(compilation, chunks) {
        const promises = [];
        chunks.forEach(chunk => {
            promises.push(...chunk.files
                .filter(fileName => fileName.endsWith('.css'))
                .map(cssFile => postcss([extractStyles(this._options)])
                .use(prefixer({ prefix: this.compilationHash, exclude: [/^\w+/] }))
                .process(compilation.assets[cssFile].source(), { from: cssFile, to: cssFile })
                .then((result) => {
                compilation.assets[cssFile] = new webpack_sources_1.RawSource(result.css.replace(new RegExp(`${this.compilationHash} `, 'g'), ''));
                return new Promise(resolve => {
                    postcss([
                        prefixer({
                            prefix: this.compilationHash,
                        }),
                        postcssPlugin_1.extractTPACustomSyntax({
                            onFinish: ({ cssVars, customSyntaxStrs, css }) => {
                                resolve({ chunk, cssVars, customSyntaxStrs, css, staticCss: result.css });
                            },
                        }),
                    ]).process(result.extracted, { from: undefined }).css;
                });
            })));
        });
        return Promise.all(promises);
    }
    replaceByPlaceHolder({ sourceCode, newSource, shouldEscapeContent, placeholder, params }) {
        const placeHolder = `'${this.compilationHash}${placeholder}'`;
        const placeHolderPos = sourceCode.indexOf(placeHolder);
        if (placeHolderPos > -1) {
            const content = JSON.stringify(params);
            const escapedContent = JSON.stringify(content);
            newSource.replace(placeHolderPos, placeHolderPos + placeHolder.length - 1, shouldEscapeContent ? escapedContent.substring(1, escapedContent.length - 1) : content);
        }
    }
    replaceSource(compilation, extractResults, shouldEscapeContent) {
        const entryMergedChunks = this.getEntryMergedChunks(extractResults);
        entryMergedChunks.forEach(({ chunk, cssVars, customSyntaxStrs, css, staticCss }) => {
            chunk.files
                .filter(fileName => fileName.endsWith('.js'))
                .forEach(file => {
                const sourceCode = compilation.assets[file].source();
                const newSource = new webpack_sources_1.ReplaceSource(compilation.assets[file], file);
                this.replaceByPlaceHolder({
                    sourceCode,
                    newSource,
                    shouldEscapeContent,
                    placeholder: 'INJECTED_DATA_PLACEHOLDER',
                    params: {
                        cssVars,
                        customSyntaxStrs,
                        css,
                    },
                });
                this.replaceByPlaceHolder({
                    sourceCode,
                    newSource,
                    shouldEscapeContent,
                    placeholder: 'INJECTED_STATIC_DATA_PLACEHOLDER',
                    params: {
                        staticCss,
                    },
                });
                compilation.assets[file] = newSource;
            });
        });
    }
    getEntryMergedChunks(extractResults) {
        const entryMergedChunks = extractResults
            .filter(({ chunk }) => chunk.canBeInitial())
            .reduce((chunkMap, currentResult) => {
            const currentChunk = currentResult.chunk;
            if (chunkMap.hasOwnProperty(currentChunk.id)) {
                chunkMap[currentChunk.id] = this.mergeExtractResults(chunkMap[currentChunk.id], currentResult);
            }
            else {
                chunkMap[currentChunk.id] = currentResult;
            }
            return chunkMap;
        }, {});
        return Object.keys(entryMergedChunks).map(key => entryMergedChunks[key]);
    }
    mergeExtractResults(extractResult1, extractResult2) {
        const newResult = Object.assign({}, extractResult1);
        newResult.cssVars = Object.assign(Object.assign({}, newResult.cssVars), extractResult2.cssVars);
        newResult.customSyntaxStrs = newResult.customSyntaxStrs.concat(extractResult2.customSyntaxStrs);
        newResult.css += `\n${extractResult2.css}`;
        newResult.staticCss += `\n${extractResult2.staticCss}`;
        return newResult;
    }
}
TPAStylePlugin.pluginName = 'tpa-style-webpack-plugin';
module.exports = TPAStylePlugin;
